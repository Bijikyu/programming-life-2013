# The controller for the Cell view
#
class Controller.Cell extends Controller.Base

	# Maximum number of iterations for the simulation
	#
	@MAX_ITERATIONS = 100
	
	# The minimum change required for a data point to be significant
	#
	@SIGNIFICANCE = 1e-15
	
	# Creates a new instance of Cell
	#
	# @overload constructor( paper, parent, model )
	#	Creates the cell view from parameters
	#	@param paper [Rapahel] the paper
	# 	@param parent [View.*] the parent view
	# 	@param model [Model.*] the model
	#
	# @overload constructor( view )
	#   Sets the cell view
	#   @param view [View.Cell] the view
	#
	constructor: ( ) ->
		view = if arguments.length is 1
			arguments[ 0 ]
		else
			new View.Cell( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] ? new Model.Cell(), arguments[ 3 ] ? on )	
		super view
				
		Object.defineProperty( @, 'model', 
			get: () -> 
				return @view.model
			set: ( value ) -> 
				@view.model = value
		)
		
	# Loads a new cell into the view
	#
	# @param cell_id [Integer] the cell to load
	# @param callback [Function] the callback function
	# @return [jQuery.Promise] the promise
	#
	load: ( cell_id, callback ) ->
	
		setcallback = ( cell ) => 
			@model = cell 
			callback?.call( @, cell )
		return Model.Cell.load cell_id, setcallback
		
	# Saves the cell view model
	#
	# @param name the name to save with
	# @return [jQuery.Promise] the promise
	#
	save: ( name ) ->
		@model.name = name ? @model.name
		return @model.save()
		
	# Get the simulation data from the cell
	# 
	# @param from [Integer] The t0 of the simulation
	# @param to [Integer] the tn of the simulation
	# @param dt [Float] The timestep for the graphs
	# @param base_values [Array] continuation values
	# @param token [CancelToken] the cancellation token
	# @param interpolate [Boolean] wether to interpolate
	# @return [Object] Object with data such as An array of datapoints
	#
	solveTheSystem: ( from, to, base_values = [], token = numeric.asynccancel(), dt = 1, interpolate = off ) ->
	
		duration = to - from
		promise = @model.run( from, to, base_values, undefined, token )
		promise = promise.then( ( cell_run ) =>
			
			results = cell_run.results
			mapping = cell_run.map
	
			xValues = []
			
			# Get the interpolation for a fixed timestep instead of the adaptive timestep
			# generated by the ODE. This should be fairly fast, since the values all 
			# already there ( ymid and f )
			if interpolate
				interpolation = []
				for time in [ 0 ... duration ] by dt
					interpolation[ time ] = results.at time
				for val in [0 ... duration] by dt
					xValues.push ( val + cell_run.from )
			else
				skip = []
				prevVal = 0
				prevVal = results.x[ 0 ] - Cell.SIGNIFICANCE if results.x.length
				for index, val of results.x
					if ( Math.abs( val - prevVal ) ) >= Cell.SIGNIFICANCE
						xValues.push ( val + cell_run.from )
						prevVal = val
					else
						skip.push index
			datasets = {}			
			for key, value of mapping
				yValues = []

				if @_interpolation
					for time in [ 0 ... duration ] by dt
						yValues.push( interpolation[ time ][ value ] ) 
				else
					for index, substance of results.y
						unless index is _( skip ).first()
							yValues.push(substance[value])
						else
							skip.pop()
					
				datasets[ key ] = { xValues: xValues, yValues: yValues}
				
			return { 
				results: results
				datasets: datasets
				from: cell_run.from
				to: cell_run.to
			}
		)
		
		return promise
		
	# Sets the simulation state
	#
	# @param startSimulateFlag [Boolean] flag to start the simulation
	# @param callback [Function] the callback function after each iteration
	# @param t [Integer] duration of each step call
	# @param iterations [Integer] maximum t to run
	# @param dt [Integer] graph dt
	# @return [ Tuple<CancelToken, jQuery.Promise> ] tuple
	#
	setSimulationState: ( startSimulateFlag, callback, t, iterations, dt ) ->
		if startSimulateFlag
			return @startSimulation( t, iterations, callback, dt )
		return @stopSimulation()
		
	# Starts the simulation
	# 
	# @param t [Integer] duration of each step call
	# @param iterations [Integer] maximum t to run
	# @param callback [Function] the callback function after each iteration
	# @param dt [Integer] graph dt
	# @return [ Tuple<CancelToken, jQuery.Promise> ] tuple of token and promise
	#
	startSimulation: ( t = 20, iterations = Cell.MAX_ITERATIONS, callback, dt = 0.001 ) ->
		
		@_running = on
		@_token = numeric.asynccancel()
		
		# This creates a version of the step function, with the parameters
		# given filled in as a partial. It is throtthed over step_update. This
		# means that you can call it an infinite number of times, but it will
		# only be executed after step_update passes.
		#
		step = _( @_step )
			.chain()
			.bind( @, dt, callback )
			.value()
		
		@_trigger( "simulation.start", @, [ @model ] )
		
		promise = @_simulate( step, t, iterations )		
		return [ @_token, promise ]
		
	# Steps the simulation
	#
	# @param t [Integer] the duration of this step
	# @param dt [Integer] the dt of the graphs
	# @param callback [Function] the callback after each iteration
	# @param base_values [Array<Float>] the previous values
	# @param max [Integer] max t
	# @return [Array<Float>] the new values
	#
	_step : ( dt, callback, from, to, base_values ) ->
	
		return base_values unless @_running
		
		promise = @solveTheSystem( from, to, base_values, @_token, dt )
		promise = promise.then( ( cell_data ) =>
			callback?( cell_data, cell_data.from, cell_data.to )
			return [ _( cell_data.results.y ).last(), cell_data.from, cell_data.to ]
		)
		
		return promise
	
	# Simulation handler
	#
	# Actually loops the simulation. Expects step to be a throttled function
	# and gracefully defers execution of this step function. 
	#
	# @param step [Function] the step function
	# @param t [Integer] the duration T of a step
	# @param iterations [Integer] the number of iterations/steps
	# @return [jQuery.Promise] the promise
	#
	_simulate: ( step, t, iterations ) ->
		
		# While running step this function and recursively
		# call this function. But because the call is deferred,
		# the call_stack is emptied before execution.
		#
		# @param step [Function] step function
		# @param from [Integer] the t0 of the simulation
		# @param to [Integer] the tn of the simulation
		# @param args [any*] arguments to pass
		# @return [jQuery.Promise] the promise
		#
		simulation = ( step, from, to, args ) => 
			if @_running
				promise = step( from, to, args ) 
				promise = promise.then( ( results, actual_from, actual_to ) =>
					data = results[ 0 ]
					actual_from = results[ 1 ]
					actual_to = results[ 2 ]
					@stopSimulation() if ( --iterations <= 0 )
					return simulation( step, actual_to, actual_to + t, data ) if @_running
					return null
				)
			return promise
			
		return simulation( step, 0, t, [] )
		
	# Stops the simulation
	#
	# @return [ Tuple<CancelToken, jQuery.Promise> ] tuple of token and promise
	#
	stopSimulation: ( ) ->
		@_running = off
		@_trigger( "simulation.stop", @, [ @model ] )
		return [ @_token, undefined ]
