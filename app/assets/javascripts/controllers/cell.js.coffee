# The controller for the Cell view
#
class Controller.Cell extends Controller.Base

	@concern Mixin.EventBindings

	# Creates a new instance of Cell
	#
	# @overload constructor( paper, parent, model )
	#	Creates the cell view from parameters
	#	@param paper [Rapahel] the paper
	# 	@param parent [View.*] the parent view
	# 	@param model [Model.*] the model
	#
	# @overload constructor( view )
	#   Sets the cell view
	#   @param view [View.Cell] the view
	#
	constructor: ( ) ->
		view = if arguments.length is 1
			arguments[ 0 ]
		else
			new View.Cell( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] ? new Model.Cell() )	
		super view
				
		@_interpolation = off
		@_significance = 1e-15
		
		Object.defineProperty( @, 'model', 
			get: () -> 
				return @view.model
			set: ( value ) -> 
				@view.model = value
		)
		
	# Loads a new cell into the view
	#
	# @param cell_id [Integer] the cell to load
	# @param callback [Function] the callback function
	# @return [jQuery.Promise] the promise
	#
	load: ( cell_id, callback ) ->
	
		setcallback = ( cell ) => 
			@model = cell 
			callback?.call( @, cell )
		return Model.Cell.load cell_id, setcallback
		
	# Saves the cell view model
	#
	# @return [jQuery.Promise] the promise
	#
	save: ( name ) ->
		@model.name = name ? @model.name
		return @model.save()
		
	# Get the simulation data from the cell
	# 
	# @param duration [Integer] The duration of the simulation
	# @param dt [Float] The timestep for the graphs
	# @param base_values [Array] continuation values
	# @return [Object] Object with data such as An array of datapoints
	#
	runOdeFor: ( duration, base_values = [], dt = 1, iteration = 0, token = numeric.asynccancel() ) ->
	
		promise = @model.run( duration, base_values, iteration, token )
		promise = promise.then( ( cell_run ) =>
			
			results = cell_run.results
			mapping = cell_run.map
			
			# This keeps track of where in the simulation we are. If we provide base values
			# and an iteration number, we can keep track of where the duration is located
			iteration = iteration + 1
			iteration = 1 unless cell_run.append

			# Get the interpolation for a fixed timestep instead of the adaptive timestep
			# generated by the ODE. This should be fairly fast, since the values all 
			# already there ( ymid and f )
			if @_interpolation
				interpolation = []
				for time in [ 0 ... duration ] by dt
					interpolation[ time ] = results.at time;

			datasets = {}

			xValues = []
			skip = []
			prevVal = 0
			prevVal = results.x[ 0 ] - @_significance if results.x.length

			if @_interpolation
				for val in [0 ... duration] by dt
					xValues.push (val + ((iteration - 1) * duration))
			else
				for index, val of results.x
					if ( Math.abs( val - prevVal ) ) >= @_significance
						xValues.push (val + ((iteration - 1) * duration))
						prevVal = val
					else
						skip.push index
						
			for key, value of mapping
				yValues = []

				if @_interpolation
					for time in [ 0 ... duration ] by dt
						yValues.push( interpolation[ time ][ value ] ) 
				else
					for index, substance of results.y
						unless index is _( skip ).first()
							yValues.push(substance[value])
						else
							skip.pop()
					
				datasets[ key ] = { xValues: xValues, yValues: yValues}

			return { 
				results: results
				datasets: datasets
				from: duration * ( iteration - 1 )
				to: ( duration * iteration )
				iteration: iteration
			}
		)
		
		return promise
		
	# Sets the simulation state
	#
	# @param startSimulateFlag [Boolean] flag to start the simulation
	#
	setSimulationState: ( startSimulateFlag ) ->
		if startSimulateFlag
			return @startSimulation( 25, 0, 50 )
		return @stopSimulation()
		
	# Starts drawing the simulation
	# 
	# @param step_duration [Integer] duration of each step call
	# @param step_update [Integer] time between steps
	# @param max [Integer] max t
	# @param dt [Integer] graph dt
	#
	startSimulation: ( step_duration = 20, step_update = 2000, max = View.Cell.MAX_RUNTIME, dt = 0.001 ) ->
		
		@_running = on
		@_iteration = 0
		@_token = numeric.asynccancel()
		
		# This creates a version of the step function, with the parameters
		# given filled in as a partial. It is throtthed over step_update. This
		# means that you can call it an infinite number of times, but it will
		# only be executed after step_update passes.
		step = _( @_step )
			.chain()
			.bind( @, step_duration, dt, max )
			.throttle( step_update )
			.value()
		
		# Actually simulate
		promise = @_simulate( step )
	
		@_trigger("simulation.start",@, [ @model ])
		
		return [ promise, @_token ]
		
	# Steps the simulation
	#
	# @param duration [Integer] the duration of this step
	# @param dt [Integer] the dt of the graphs
	# @param base_values [Array<Float>] the previous values
	# @param max [Integer] max t
	# @return [Array<Float>] the new values
	#
	# @todo view.drawGraphs should be extracted
	#
	_step : ( duration, dt, max, base_values ) ->
	
		return base_values unless @_running
		
		promise = @runOdeFor( duration, base_values, dt, @_iteration, @_token )
		promise = promise.then( ( cell_data ) =>
			@_iteration = cell_data.iteration
			console.log cell_data
			@view._drawGraphs( cell_data.datasets, 0, 0, @_iteration > 1  )

			if cell_data.to >= max
				@stopSimulation()
			
			return _( cell_data.results.y ).last()
		)
		
		return promise
	
	# Simulation handler
	#
	# Actually loops the simulation. Expects step to be a throttled function
	# and gracefully defers execution of this step function. 
	#
	_simulate: ( step ) ->
		
		# While running step this function and recursively
		# call this function. But because the call is deferred,
		# the call_stack is emptied before execution.
		#
		# @param step [Function] step function
		# @param results [any*] arguments to pass
		simulation = ( step, args ) => 
		
			if @_running
				promise = step( args ) 
				promise = promise.then( ( results ) =>
					return simulation( step, results ) if @_running
					return null
				)
			return promise
			
		return simulation( step, [] )
		
	# Stops the simulation
	#
	stopSimulation: ( ) ->
		@_running = off

		@_trigger( "simulation.stop", @, [ @model ] )
		return [ undefined, @_token ]