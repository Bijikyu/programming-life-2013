<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>backbone.js - RDoc Documentation</title>

<link type="text/css" media="screen" href="../../../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
</script>

<script type="text/javascript" charset="utf-8" src="../../../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../../../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../../../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../../../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../../../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../../../js/darkfish.js"></script>


<body class="file">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../../../index.html">Home</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../../../Gemfile.html">Gemfile</a>
  
    <li class="file"><a href="../../../Gemfile_lock.html">Gemfile.lock</a>
  
    <li class="file"><a href="../../../README_md.html">README</a>
  
    <li class="file"><a href="../../../README_rdoc.html">README</a>
  
    <li class="file"><a href="../../../Rakefile.html">Rakefile</a>
  
    <li class="file"><a href="../../../app/assets/javascripts/Module_js_coffee.html">Module.js.coffee</a>
  
    <li class="file"><a href="../../../app/assets/javascripts/application_js.html">application.js</a>
  
    <li class="file"><a href="../../../app/assets/javascripts/hook_js_coffee.html">hook.js.coffee</a>
  
    <li class="file"><a href="../../../app/assets/javascripts/jasmine_examples/Player_js.html">Player.js</a>
  
    <li class="file"><a href="../../../app/assets/javascripts/jasmine_examples/Song_js.html">Song.js</a>
  
    <li class="file"><a href="../../../app/assets/javascripts/main_js_coffee.html">main.js.coffee</a>
  
    <li class="file"><a href="../../../app/assets/stylesheets/application_css.html">application.css</a>
  
    <li class="file"><a href="../../../app/assets/stylesheets/hook_css_scss.html">hook.css.scss</a>
  
    <li class="file"><a href="../../../app/assets/stylesheets/main_css_scss.html">main.css.scss</a>
  
    <li class="file"><a href="../../../config_ru.html">config.ru</a>
  
    <li class="file"><a href="../../../db/development_sqlite3.html">development.sqlite3</a>
  
    <li class="file"><a href="../../../doc/server/created_rid.html">created.rid</a>
  
    <li class="file"><a href="../../../docs/deliverables/Emergent Architertural Design_tex.html">Emergent Architertural Design.tex</a>
  
    <li class="file"><a href="../../../docs/deliverables/summaries/Seminar 2/Samenvatting_tex.html">Samenvatting.tex</a>
  
    <li class="file"><a href="../../../docs/deliverables/summaries/Seminar 2/samenvatting-Mathematics-of-Biology_tex.html">samenvatting-Mathematics-of-Biology.tex</a>
  
    <li class="file"><a href="../../../docs/planning samenvatten_txt.html">planning samenvatten</a>
  
    <li class="file"><a href="../../../hook_php.html">hook.php</a>
  
    <li class="file"><a href="../../../log/development_log.html">development.log</a>
  
    <li class="file"><a href="../../../public/404_html.html">404.html</a>
  
    <li class="file"><a href="../../../public/422_html.html">422.html</a>
  
    <li class="file"><a href="../../../public/500_html.html">500.html</a>
  
    <li class="file"><a href="../../../public/favicon_ico.html">favicon.ico</a>
  
    <li class="file"><a href="../../../public/robots_txt.html">robots</a>
  
    <li class="file"><a href="../../../spec/javascripts/ModuleSpec_js.html">ModuleSpec.js</a>
  
    <li class="file"><a href="../../../spec/javascripts/helpers/SpecHelper_js.html">SpecHelper.js</a>
  
    <li class="file"><a href="../../../vendor/assets/javascripts/backbone_js.html">backbone.js</a>
  
    <li class="file"><a href="../../../vendor/assets/javascripts/underscore_js.html">underscore.js</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../../../ActiveSupport.html">ActiveSupport</a>
  
    <li><a href="../../../ActiveSupport/TestCase.html">ActiveSupport::TestCase</a>
  
    <li><a href="../../../ApplicationController.html">ApplicationController</a>
  
    <li><a href="../../../ApplicationHelper.html">ApplicationHelper</a>
  
    <li><a href="../../../BrowsingTest.html">BrowsingTest</a>
  
    <li><a href="../../../GreetingsControllerTest.html">GreetingsControllerTest</a>
  
    <li><a href="../../../GreetingsHelperTest.html">GreetingsHelperTest</a>
  
    <li><a href="../../../HookController.html">HookController</a>
  
    <li><a href="../../../HookControllerTest.html">HookControllerTest</a>
  
    <li><a href="../../../HookHelper.html">HookHelper</a>
  
    <li><a href="../../../HookHelperTest.html">HookHelperTest</a>
  
    <li><a href="../../../MainController.html">MainController</a>
  
    <li><a href="../../../MainControllerTest.html">MainControllerTest</a>
  
    <li><a href="../../../MainHelper.html">MainHelper</a>
  
    <li><a href="../../../MainHelperTest.html">MainHelperTest</a>
  
    <li><a href="../../../Object.html">Object</a>
  
    <li><a href="../../../ProgrammingLife.html">ProgrammingLife</a>
  
    <li><a href="../../../ProgrammingLife/Application.html">ProgrammingLife::Application</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation" class="description">
  
<p>//     Backbone.js 1.0.0</p>

<p>//     Â© 2010-2013 Jeremy Ashkenas, DocumentCloud Inc. //     Backbone may
be freely distributed under the MIT license. //     For all details and
documentation: //     <a href="http://backbonejs.org">backbonejs.org</a></p>

<p>(function(){</p>

<pre class="ruby"><span class="ruby-regexp">//</span> <span class="ruby-constant">Initial</span> <span class="ruby-constant">Setup</span>
<span class="ruby-regexp">//</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span>

<span class="ruby-regexp">//</span> <span class="ruby-constant">Save</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">reference</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">global</span> <span class="ruby-identifier">object</span> (<span class="ruby-value">%xwindow`</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">browser</span>, <span class="ruby-value">%xexports`</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">server</span>).
<span class="ruby-identifier">var</span> <span class="ruby-identifier">root</span> = <span class="ruby-identifier">this</span>;

<span class="ruby-regexp">//</span> <span class="ruby-constant">Save</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">previous</span> <span class="ruby-identifier">value</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-value">%xBackbone`</span> <span class="ruby-identifier">variable</span>, <span class="ruby-identifier">so</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">can</span> <span class="ruby-identifier">be</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">restored</span> <span class="ruby-identifier">later</span> <span class="ruby-identifier">on</span>, <span class="ruby-keyword">if</span> <span class="ruby-value">%xnoConflict`</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">used</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">previousBackbone</span> = <span class="ruby-identifier">root</span>.<span class="ruby-constant">Backbone</span>;

<span class="ruby-regexp">//</span> <span class="ruby-constant">Create</span> <span class="ruby-identifier">local</span> <span class="ruby-identifier">references</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">array</span> <span class="ruby-identifier">methods</span> <span class="ruby-identifier">we</span><span class="ruby-string">'ll want to use later.
var array = [];
var push = array.push;
var slice = array.slice;
var splice = array.splice;

// The top-level namespace. All public Backbone classes and modules will
// be attached to this. Exported for both the browser and the server.
var Backbone;
if (typeof exports !== '</span><span class="ruby-identifier">undefined</span><span class="ruby-string">') {
  Backbone = exports;
} else {
  Backbone = root.Backbone = {};
}

// Current version of the library. Keep in sync with `package.json`.
Backbone.VERSION = '</span><span class="ruby-value">1.0</span><span class="ruby-value">.0</span><span class="ruby-string">';

// Require Underscore, if we'</span><span class="ruby-identifier">re</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">server</span>, <span class="ruby-keyword">and</span> <span class="ruby-identifier">it</span><span class="ruby-string">'s not already present.
var _ = root._;
if (!_ &amp;&amp; (typeof require !== '</span><span class="ruby-identifier">undefined</span><span class="ruby-string">')) _ = require('</span><span class="ruby-identifier">underscore</span><span class="ruby-string">');

// For Backbone'</span><span class="ruby-identifier">s</span> <span class="ruby-identifier">purposes</span>, <span class="ruby-identifier">jQuery</span>, <span class="ruby-constant">Zepto</span>, <span class="ruby-constant">Ender</span>, <span class="ruby-keyword">or</span> <span class="ruby-constant">My</span> <span class="ruby-constant">Library</span> (<span class="ruby-identifier">kidding</span>) <span class="ruby-identifier">owns</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">the</span> <span class="ruby-value">%x$`</span> <span class="ruby-identifier">variable</span>.
<span class="ruby-constant">Backbone</span>.$ = <span class="ruby-identifier">root</span>.<span class="ruby-identifier">jQuery</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">root</span>.<span class="ruby-constant">Zepto</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">root</span>.<span class="ruby-identifier">ender</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">root</span>.<span class="ruby-identifier">$;</span>

<span class="ruby-regexp">//</span> <span class="ruby-constant">Runs</span> <span class="ruby-constant">Backbone</span>.<span class="ruby-identifier">js</span> <span class="ruby-keyword">in</span> <span class="ruby-operator">*</span><span class="ruby-identifier">noConflict</span><span class="ruby-operator">*</span> <span class="ruby-identifier">mode</span>, <span class="ruby-identifier">returning</span> <span class="ruby-identifier">the</span> <span class="ruby-value">%xBackbone`</span> <span class="ruby-identifier">variable</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">its</span> <span class="ruby-identifier">previous</span> <span class="ruby-identifier">owner</span>. <span class="ruby-constant">Returns</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">reference</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">this</span> <span class="ruby-constant">Backbone</span> <span class="ruby-identifier">object</span>.
<span class="ruby-constant">Backbone</span>.<span class="ruby-identifier">noConflict</span> = <span class="ruby-identifier">function</span>() {
  <span class="ruby-identifier">root</span>.<span class="ruby-constant">Backbone</span> = <span class="ruby-identifier">previousBackbone</span>;
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
};

<span class="ruby-regexp">//</span> <span class="ruby-constant">Turn</span> <span class="ruby-identifier">on</span> <span class="ruby-value">%xemulateHTTP`</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">support</span> <span class="ruby-identifier">legacy</span> <span class="ruby-constant">HTTP</span> <span class="ruby-identifier">servers</span>. <span class="ruby-constant">Setting</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">option</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">will</span> <span class="ruby-identifier">fake</span> <span class="ruby-value">%x&quot;PUT&quot;`</span> <span class="ruby-keyword">and</span> <span class="ruby-value">%x&quot;DELETE&quot;`</span> <span class="ruby-identifier">requests</span> <span class="ruby-identifier">via</span> <span class="ruby-identifier">the</span> <span class="ruby-value">%x_method`</span> <span class="ruby-identifier">parameter</span> <span class="ruby-keyword">and</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">a</span> <span class="ruby-value">%xX-Http-Method-Override`</span> <span class="ruby-identifier">header</span>.
<span class="ruby-constant">Backbone</span>.<span class="ruby-identifier">emulateHTTP</span> = <span class="ruby-keyword">false</span>;

<span class="ruby-regexp">//</span> <span class="ruby-constant">Turn</span> <span class="ruby-identifier">on</span> <span class="ruby-value">%xemulateJSON`</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">support</span> <span class="ruby-identifier">legacy</span> <span class="ruby-identifier">servers</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">can</span><span class="ruby-string">'t deal with direct
// `application/json` requests ... will encode the body as
// `application/x-www-form-urlencoded` instead and will send the model in a
// form param named `model`.
Backbone.emulateJSON = false;

// Backbone.Events
// ---------------

// A module that can be mixed in to *any object* in order to provide it with
// custom events. You may bind with `on` or remove with `off` callback
// functions to an event; `trigger`-ing an event fires all callbacks in
// succession.
//
//     var object = {};
//     _.extend(object, Backbone.Events);
//     object.on('</span><span class="ruby-identifier">expand</span><span class="ruby-string">', function(){ alert('</span><span class="ruby-identifier">expanded</span><span class="ruby-string">'); });
//     object.trigger('</span><span class="ruby-identifier">expand</span><span class="ruby-string">');
//
var Events = Backbone.Events = {

  // Bind an event to a `callback` function. Passing `&quot;all&quot;` will bind
  // the callback to all events fired.
  on: function(name, callback, context) {
    if (!eventsApi(this, '</span><span class="ruby-identifier">on</span><span class="ruby-string">', name, [callback, context]) || !callback) return this;
    this._events || (this._events = {});
    var events = this._events[name] || (this._events[name] = []);
    events.push({callback: callback, context: context, ctx: context || this});
    return this;
  },

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, it will be removed.
  once: function(name, callback, context) {
    if (!eventsApi(this, '</span><span class="ruby-identifier">once</span><span class="ruby-string">', name, [callback, context]) || !callback) return this;
    var self = this;
    var once = _.once(function() {
      self.off(name, once);
      callback.apply(this, arguments);
    });
    once._callback = callback;
    return this.on(name, once, context);
  },

  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  off: function(name, callback, context) {
    var retain, ev, events, names, i, l, j, k;
    if (!this._events || !eventsApi(this, '</span><span class="ruby-identifier">off</span><span class="ruby-string">', name, [callback, context])) return this;
    if (!name &amp;&amp; !callback &amp;&amp; !context) {
      this._events = {};
      return this;
    }

    names = name ? [name] : _.keys(this._events);
    for (i = 0, l = names.length; i &lt; l; i++) {
      name = names[i];
      if (events = this._events[name]) {
        this._events[name] = retain = [];
        if (callback || context) {
          for (j = 0, k = events.length; j &lt; k; j++) {
            ev = events[j];
            if ((callback &amp;&amp; callback !== ev.callback &amp;&amp; callback !== ev.callback._callback) ||
                (context &amp;&amp; context !== ev.context)) {
              retain.push(ev);
            }
          }
        }
        if (!retain.length) delete this._events[name];
      }
    }

    return this;
  },

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you'</span><span class="ruby-identifier">re</span> <span class="ruby-identifier">listening</span> <span class="ruby-identifier">on</span> <span class="ruby-value">%x&quot;all&quot;`</span>, <span class="ruby-identifier">which</span> <span class="ruby-identifier">will</span> <span class="ruby-identifier">cause</span> <span class="ruby-identifier">your</span> <span class="ruby-identifier">callback</span> <span class="ruby-identifier">to</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">receive</span> <span class="ruby-identifier">the</span> <span class="ruby-keyword">true</span> <span class="ruby-identifier">name</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">event</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">first</span> <span class="ruby-identifier">argument</span>).
  <span class="ruby-identifier">trigger</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">_events</span>) <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">args</span> = <span class="ruby-identifier">slice</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">arguments</span>, <span class="ruby-value">1</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">eventsApi</span>(<span class="ruby-identifier">this</span>, <span class="ruby-string">'trigger'</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">args</span>)) <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">events</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_events</span>[<span class="ruby-identifier">name</span>];
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">allEvents</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_events</span>.<span class="ruby-identifier">all</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">events</span>) <span class="ruby-identifier">triggerEvents</span>(<span class="ruby-identifier">events</span>, <span class="ruby-identifier">args</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">allEvents</span>) <span class="ruby-identifier">triggerEvents</span>(<span class="ruby-identifier">allEvents</span>, <span class="ruby-identifier">arguments</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Tell</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">object</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">stop</span> <span class="ruby-identifier">listening</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">either</span> <span class="ruby-identifier">specific</span> <span class="ruby-identifier">events</span> <span class="ruby-operator">...</span> <span class="ruby-keyword">or</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">every</span> <span class="ruby-identifier">object</span> <span class="ruby-identifier">it</span><span class="ruby-string">'s currently listening to.
  stopListening: function(obj, name, callback) {
    var listeners = this._listeners;
    if (!listeners) return this;
    var deleteListener = !name &amp;&amp; !callback;
    if (typeof name === '</span><span class="ruby-identifier">object</span><span class="ruby-string">') callback = this;
    if (obj) (listeners = {})[obj._listenerId] = obj;
    for (var id in listeners) {
      listeners[id].off(name, callback, this);
      if (deleteListener) delete this._listeners[id];
    }
    return this;
  }

};

// Regular expression used to split event strings.
var eventSplitter = /\s+/;

// Implement fancy features of the Events API such as multiple event
// names `&quot;change blur&quot;` and jQuery-style event maps `{change: action}`
// in terms of the existing API.
var eventsApi = function(obj, action, name, rest) {
  if (!name) return true;

  // Handle event maps.
  if (typeof name === '</span><span class="ruby-identifier">object</span><span class="ruby-string">') {
    for (var key in name) {
      obj[action].apply(obj, [key, name[key]].concat(rest));
    }
    return false;
  }

  // Handle space separated event names.
  if (eventSplitter.test(name)) {
    var names = name.split(eventSplitter);
    for (var i = 0, l = names.length; i &lt; l; i++) {
      obj[action].apply(obj, [names[i]].concat(rest));
    }
    return false;
  }

  return true;
};

// A difficult-to-believe, but optimized internal dispatch function for
// triggering events. Tries to keep the usual cases speedy (most internal
// Backbone events have 3 arguments).
var triggerEvents = function(events, args) {
  var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
  switch (args.length) {
    case 0: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx); return;
    case 1: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1); return;
    case 2: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
    case 3: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
    default: while (++i &lt; l) (ev = events[i]).callback.apply(ev.ctx, args);
  }
};

var listenMethods = {listenTo: '</span><span class="ruby-identifier">on</span><span class="ruby-string">', listenToOnce: '</span><span class="ruby-identifier">once</span><span class="ruby-string">'};

// Inversion-of-control versions of `on` and `once`. Tell *this* object to
// listen to an event in another object ... keeping track of what it'</span><span class="ruby-identifier">s</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">listening</span> <span class="ruby-identifier">to</span>.
<span class="ruby-identifier">_</span>.<span class="ruby-identifier">each</span>(<span class="ruby-identifier">listenMethods</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">implementation</span>, <span class="ruby-identifier">method</span>) {
  <span class="ruby-constant">Events</span>[<span class="ruby-identifier">method</span>] = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">obj</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">callback</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">listeners</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_listeners</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_listeners</span> = {});
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">id</span> = <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">_listenerId</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">_listenerId</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">uniqueId</span>(<span class="ruby-string">'l'</span>));
    <span class="ruby-identifier">listeners</span>[<span class="ruby-identifier">id</span>] = <span class="ruby-identifier">obj</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">typeof</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">===</span> <span class="ruby-string">'object'</span>) <span class="ruby-identifier">callback</span> = <span class="ruby-identifier">this</span>;
    <span class="ruby-identifier">obj</span>[<span class="ruby-identifier">implementation</span>](<span class="ruby-identifier">name</span>, <span class="ruby-identifier">callback</span>, <span class="ruby-identifier">this</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };
});

<span class="ruby-regexp">//</span> <span class="ruby-constant">Aliases</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">backwards</span> <span class="ruby-identifier">compatibility</span>.
<span class="ruby-constant">Events</span>.<span class="ruby-identifier">bind</span>   = <span class="ruby-constant">Events</span>.<span class="ruby-identifier">on</span>;
<span class="ruby-constant">Events</span>.<span class="ruby-identifier">unbind</span> = <span class="ruby-constant">Events</span>.<span class="ruby-identifier">off</span>;

<span class="ruby-regexp">//</span> <span class="ruby-constant">Allow</span> <span class="ruby-identifier">the</span> <span class="ruby-value">%xBackbone`</span> <span class="ruby-identifier">object</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">serve</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">global</span> <span class="ruby-identifier">event</span> <span class="ruby-identifier">bus</span>, <span class="ruby-keyword">for</span> <span class="ruby-identifier">folks</span> <span class="ruby-identifier">who</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">want</span> <span class="ruby-identifier">global</span> <span class="ruby-string">&quot;pubsub&quot;</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">convenient</span> <span class="ruby-identifier">place</span>.
<span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">Backbone</span>, <span class="ruby-constant">Events</span>);

<span class="ruby-regexp">//</span> <span class="ruby-constant">Backbone</span>.<span class="ruby-constant">Model</span>
<span class="ruby-regexp">//</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span>

<span class="ruby-regexp">//</span> <span class="ruby-constant">Backbone</span> <span class="ruby-operator">**</span><span class="ruby-constant">Models</span><span class="ruby-operator">**</span> <span class="ruby-identifier">are</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">basic</span> <span class="ruby-identifier">data</span> <span class="ruby-identifier">object</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">framework</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">frequently</span> <span class="ruby-identifier">representing</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">row</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">table</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">database</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">your</span> <span class="ruby-identifier">server</span>.
<span class="ruby-operator">/</span><span class="ruby-regexp">/ A discrete chunk of data and a bunch of useful, related methods for
/</span><span class="ruby-operator">/</span> <span class="ruby-identifier">performing</span> <span class="ruby-identifier">computations</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">transformations</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">data</span>.

<span class="ruby-operator">/</span><span class="ruby-regexp">/ Create a new model with the specified attributes. A client id (`cid`)
/</span><span class="ruby-operator">/</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">automatically</span> <span class="ruby-identifier">generated</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">assigned</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">you</span>.
<span class="ruby-identifier">var</span> <span class="ruby-constant">Model</span> = <span class="ruby-constant">Backbone</span>.<span class="ruby-constant">Model</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">options</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">defaults</span>;
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">attrs</span> = <span class="ruby-identifier">attributes</span> <span class="ruby-operator">||</span> {};
  <span class="ruby-identifier">options</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">options</span> = {});
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cid</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">uniqueId</span>(<span class="ruby-string">'c'</span>);
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">attributes</span> = {};
  <span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">_</span>.<span class="ruby-identifier">pick</span>(<span class="ruby-identifier">options</span>, <span class="ruby-identifier">modelOptions</span>));
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">parse</span>) <span class="ruby-identifier">attrs</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">attrs</span>, <span class="ruby-identifier">options</span>) <span class="ruby-operator">||</span> {};
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">defaults</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">result</span>(<span class="ruby-identifier">this</span>, <span class="ruby-string">'defaults'</span>)) {
    <span class="ruby-identifier">attrs</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">defaults</span>({}, <span class="ruby-identifier">attrs</span>, <span class="ruby-identifier">defaults</span>);
  }
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">attrs</span>, <span class="ruby-identifier">options</span>);
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">changed</span> = {};
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">initialize</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
};

<span class="ruby-regexp">//</span> <span class="ruby-constant">A</span> <span class="ruby-identifier">list</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">options</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">attached</span> <span class="ruby-identifier">directly</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">model</span>, <span class="ruby-keyword">if</span> <span class="ruby-identifier">provided</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">modelOptions</span> = [<span class="ruby-string">'url'</span>, <span class="ruby-string">'urlRoot'</span>, <span class="ruby-string">'collection'</span>];

<span class="ruby-regexp">//</span> <span class="ruby-constant">Attach</span> <span class="ruby-identifier">all</span> <span class="ruby-identifier">inheritable</span> <span class="ruby-identifier">methods</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-constant">Model</span> <span class="ruby-identifier">prototype</span>.
<span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">Model</span>.<span class="ruby-identifier">prototype</span>, <span class="ruby-constant">Events</span>, {

  <span class="ruby-regexp">//</span> <span class="ruby-constant">A</span> <span class="ruby-identifier">hash</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">attributes</span> <span class="ruby-identifier">whose</span> <span class="ruby-identifier">current</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">previous</span> <span class="ruby-identifier">value</span> <span class="ruby-identifier">differ</span>.
  <span class="ruby-identifier">changed</span><span class="ruby-operator">:</span> <span class="ruby-identifier">null</span>,

  <span class="ruby-regexp">//</span> <span class="ruby-constant">The</span> <span class="ruby-identifier">value</span> <span class="ruby-identifier">returned</span> <span class="ruby-identifier">during</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">last</span> <span class="ruby-identifier">failed</span> <span class="ruby-identifier">validation</span>.
  <span class="ruby-identifier">validationError</span><span class="ruby-operator">:</span> <span class="ruby-identifier">null</span>,

  <span class="ruby-regexp">//</span> <span class="ruby-constant">The</span> <span class="ruby-identifier">default</span> <span class="ruby-identifier">name</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">the</span> <span class="ruby-constant">JSON</span> <span class="ruby-value">%xid`</span> <span class="ruby-identifier">attribute</span> <span class="ruby-identifier">is</span> <span class="ruby-value">%x&quot;id&quot;`</span>. <span class="ruby-constant">MongoDB</span> <span class="ruby-keyword">and</span>
  <span class="ruby-regexp">//</span> <span class="ruby-constant">CouchDB</span> <span class="ruby-identifier">users</span> <span class="ruby-identifier">may</span> <span class="ruby-identifier">want</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">to</span> <span class="ruby-value">%x&quot;_id&quot;`</span>.
  <span class="ruby-identifier">idAttribute</span><span class="ruby-operator">:</span> <span class="ruby-string">'id'</span>,

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Initialize</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">empty</span> <span class="ruby-identifier">function</span> <span class="ruby-identifier">by</span> <span class="ruby-identifier">default</span>. <span class="ruby-constant">Override</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">your</span> <span class="ruby-identifier">own</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">initialization</span> <span class="ruby-identifier">logic</span>.
  <span class="ruby-identifier">initialize</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(){},

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Return</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">copy</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">model</span><span class="ruby-string">'s `attributes` object.
  toJSON: function(options) {
    return _.clone(this.attributes);
  },

  // Proxy `Backbone.sync` by default -- but override this if you need
  // custom syncing semantics for *this* particular model.
  sync: function() {
    return Backbone.sync.apply(this, arguments);
  },

  // Get the value of an attribute.
  get: function(attr) {
    return this.attributes[attr];
  },

  // Get the HTML-escaped value of an attribute.
  escape: function(attr) {
    return _.escape(this.get(attr));
  },

  // Returns `true` if the attribute contains a value that is not null
  // or undefined.
  has: function(attr) {
    return this.get(attr) != null;
  },

  // Set a hash of model attributes on the object, firing `&quot;change&quot;`. This is
  // the core primitive operation of a model, updating the data and notifying
  // anyone who needs to know about the change in state. The heart of the beast.
  set: function(key, val, options) {
    var attr, attrs, unset, changes, silent, changing, prev, current;
    if (key == null) return this;

    // Handle both `&quot;key&quot;, value` and `{key: value}` -style arguments.
    if (typeof key === '</span><span class="ruby-identifier">object</span><span class="ruby-string">') {
      attrs = key;
      options = val;
    } else {
      (attrs = {})[key] = val;
    }

    options || (options = {});

    // Run validation.
    if (!this._validate(attrs, options)) return false;

    // Extract attributes and options.
    unset           = options.unset;
    silent          = options.silent;
    changes         = [];
    changing        = this._changing;
    this._changing  = true;

    if (!changing) {
      this._previousAttributes = _.clone(this.attributes);
      this.changed = {};
    }
    current = this.attributes, prev = this._previousAttributes;

    // Check for changes of `id`.
    if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

    // For each `set` attribute, update or delete the current value.
    for (attr in attrs) {
      val = attrs[attr];
      if (!_.isEqual(current[attr], val)) changes.push(attr);
      if (!_.isEqual(prev[attr], val)) {
        this.changed[attr] = val;
      } else {
        delete this.changed[attr];
      }
      unset ? delete current[attr] : current[attr] = val;
    }

    // Trigger all relevant attribute changes.
    if (!silent) {
      if (changes.length) this._pending = true;
      for (var i = 0, l = changes.length; i &lt; l; i++) {
        this.trigger('</span><span class="ruby-identifier">change</span><span class="ruby-operator">:</span><span class="ruby-string">' + changes[i], this, current[changes[i]], options);
      }
    }

    // You might be wondering why there'</span><span class="ruby-identifier">s</span> <span class="ruby-identifier">a</span> <span class="ruby-value">%xwhile`</span> <span class="ruby-identifier">loop</span> <span class="ruby-identifier">here</span>. <span class="ruby-constant">Changes</span> <span class="ruby-identifier">can</span>
    <span class="ruby-regexp">//</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">recursively</span> <span class="ruby-identifier">nested</span> <span class="ruby-identifier">within</span> <span class="ruby-value">%x&quot;change&quot;`</span> <span class="ruby-identifier">events</span>.
    <span class="ruby-identifier">if</span> (<span class="ruby-identifier">changing</span>) <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">silent</span>) {
      <span class="ruby-keyword">while</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_pending</span>) {
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_pending</span> = <span class="ruby-keyword">false</span>;
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">trigger</span>(<span class="ruby-string">'change'</span>, <span class="ruby-identifier">this</span>, <span class="ruby-identifier">options</span>);
      }
    }
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_pending</span> = <span class="ruby-keyword">false</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_changing</span> = <span class="ruby-keyword">false</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Remove</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">attribute</span> <span class="ruby-identifier">from</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">model</span>, <span class="ruby-identifier">firing</span> <span class="ruby-value">%x&quot;change&quot;`</span>. <span class="ruby-value">%xunset`</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">noop</span>
  <span class="ruby-regexp">//</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">attribute</span> <span class="ruby-identifier">doesn</span><span class="ruby-string">'t exist.
  unset: function(attr, options) {
    return this.set(attr, void 0, _.extend({}, options, {unset: true}));
  },

  // Clear all attributes on the model, firing `&quot;change&quot;`.
  clear: function(options) {
    var attrs = {};
    for (var key in this.attributes) attrs[key] = void 0;
    return this.set(attrs, _.extend({}, options, {unset: true}));
  },

  // Determine if the model has changed since the last `&quot;change&quot;` event.
  // If you specify an attribute name, determine if that attribute has changed.
  hasChanged: function(attr) {
    if (attr == null) return !_.isEmpty(this.changed);
    return _.has(this.changed, attr);
  },

  // Return an object containing all the attributes that have changed, or
  // false if there are no changed attributes. Useful for determining what
  // parts of a view need to be updated and/or what attributes need to be
  // persisted to the server. Unset attributes will be set to undefined.
  // You can also pass an attributes object to diff against the model,
  // determining if there *would be* a change.
  changedAttributes: function(diff) {
    if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
    var val, changed = false;
    var old = this._changing ? this._previousAttributes : this.attributes;
    for (var attr in diff) {
      if (_.isEqual(old[attr], (val = diff[attr]))) continue;
      (changed || (changed = {}))[attr] = val;
    }
    return changed;
  },

  // Get the previous value of an attribute, recorded at the time the last
  // `&quot;change&quot;` event was fired.
  previous: function(attr) {
    if (attr == null || !this._previousAttributes) return null;
    return this._previousAttributes[attr];
  },

  // Get all of the attributes of the model at the time of the previous
  // `&quot;change&quot;` event.
  previousAttributes: function() {
    return _.clone(this._previousAttributes);
  },

  // Fetch the model from the server. If the server'</span><span class="ruby-identifier">s</span> <span class="ruby-identifier">representation</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">differs</span> <span class="ruby-identifier">from</span> <span class="ruby-identifier">its</span> <span class="ruby-identifier">current</span> <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">they</span> <span class="ruby-identifier">will</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">overridden</span>,
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">triggering</span> <span class="ruby-identifier">a</span> <span class="ruby-value">%x&quot;change&quot;`</span> <span class="ruby-identifier">event</span>.
  <span class="ruby-identifier">fetch</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">options</span>) {
    <span class="ruby-identifier">options</span> = <span class="ruby-identifier">options</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">_</span>.<span class="ruby-identifier">clone</span>(<span class="ruby-identifier">options</span>) <span class="ruby-operator">:</span> {};
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">parse</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-identifier">options</span>.<span class="ruby-identifier">parse</span> = <span class="ruby-keyword">true</span>;
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">model</span> = <span class="ruby-identifier">this</span>;
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">success</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">success</span>;
    <span class="ruby-identifier">options</span>.<span class="ruby-identifier">success</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">resp</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">model</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">model</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">resp</span>, <span class="ruby-identifier">options</span>), <span class="ruby-identifier">options</span>)) <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">success</span>) <span class="ruby-identifier">success</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">resp</span>, <span class="ruby-identifier">options</span>);
      <span class="ruby-identifier">model</span>.<span class="ruby-identifier">trigger</span>(<span class="ruby-string">'sync'</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">resp</span>, <span class="ruby-identifier">options</span>);
    };
    <span class="ruby-identifier">wrapError</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">options</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">sync</span>(<span class="ruby-string">'read'</span>, <span class="ruby-identifier">this</span>, <span class="ruby-identifier">options</span>);
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Set</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">hash</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">attributes</span>, <span class="ruby-keyword">and</span> <span class="ruby-identifier">sync</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">server</span>.
  <span class="ruby-operator">/</span><span class="ruby-regexp">/ If the server returns an attributes hash that differs, the model's
  /</span><span class="ruby-operator">/</span> <span class="ruby-identifier">state</span> <span class="ruby-identifier">will</span> <span class="ruby-identifier">be</span> <span class="ruby-value">%xset`</span> <span class="ruby-identifier">again</span>.
  <span class="ruby-identifier">save</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">val</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">attrs</span>, <span class="ruby-identifier">method</span>, <span class="ruby-identifier">xhr</span>, <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">attributes</span>;

    <span class="ruby-regexp">//</span> <span class="ruby-constant">Handle</span> <span class="ruby-identifier">both</span> <span class="ruby-value">%x&quot;key&quot;, value`</span> <span class="ruby-keyword">and</span> <span class="ruby-value">%x{key: value}`</span> <span class="ruby-operator">-</span><span class="ruby-identifier">style</span> <span class="ruby-identifier">arguments</span>.
    <span class="ruby-identifier">if</span> (<span class="ruby-identifier">key</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">typeof</span> <span class="ruby-identifier">key</span> <span class="ruby-operator">===</span> <span class="ruby-string">'object'</span>) {
      <span class="ruby-identifier">attrs</span> = <span class="ruby-identifier">key</span>;
      <span class="ruby-identifier">options</span> = <span class="ruby-identifier">val</span>;
    } <span class="ruby-keyword">else</span> {
      (<span class="ruby-identifier">attrs</span> = {})[<span class="ruby-identifier">key</span>] = <span class="ruby-identifier">val</span>;
    }

    <span class="ruby-regexp">//</span> <span class="ruby-constant">If</span> <span class="ruby-identifier">we</span><span class="ruby-string">'re not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
    if (attrs &amp;&amp; (!options || !options.wait) &amp;&amp; !this.set(attrs, options)) return false;

    options = _.extend({validate: true}, options);

    // Do not persist invalid models.
    if (!this._validate(attrs, options)) return false;

    // Set temporary attributes if `{wait: true}`.
    if (attrs &amp;&amp; options.wait) {
      this.attributes = _.extend({}, attributes, attrs);
    }

    // After a successful server-side save, the client is (optionally)
    // updated with the server-side state.
    if (options.parse === void 0) options.parse = true;
    var model = this;
    var success = options.success;
    options.success = function(resp) {
      // Ensure attributes are restored during synchronous saves.
      model.attributes = attributes;
      var serverAttrs = model.parse(resp, options);
      if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
      if (_.isObject(serverAttrs) &amp;&amp; !model.set(serverAttrs, options)) {
        return false;
      }
      if (success) success(model, resp, options);
      model.trigger('</span><span class="ruby-identifier">sync</span><span class="ruby-string">', model, resp, options);
    };
    wrapError(this, options);

    method = this.isNew() ? '</span><span class="ruby-identifier">create</span><span class="ruby-string">' : (options.patch ? '</span><span class="ruby-identifier">patch</span><span class="ruby-string">' : '</span><span class="ruby-identifier">update</span><span class="ruby-string">');
    if (method === '</span><span class="ruby-identifier">patch</span><span class="ruby-string">') options.attrs = attrs;
    xhr = this.sync(method, this, options);

    // Restore attributes.
    if (attrs &amp;&amp; options.wait) this.attributes = attributes;

    return xhr;
  },

  // Destroy this model on the server if it was already persisted.
  // Optimistically removes the model from its collection, if it has one.
  // If `wait: true` is passed, waits for the server to respond before removal.
  destroy: function(options) {
    options = options ? _.clone(options) : {};
    var model = this;
    var success = options.success;

    var destroy = function() {
      model.trigger('</span><span class="ruby-identifier">destroy</span><span class="ruby-string">', model, model.collection, options);
    };

    options.success = function(resp) {
      if (options.wait || model.isNew()) destroy();
      if (success) success(model, resp, options);
      if (!model.isNew()) model.trigger('</span><span class="ruby-identifier">sync</span><span class="ruby-string">', model, resp, options);
    };

    if (this.isNew()) {
      options.success();
      return false;
    }
    wrapError(this, options);

    var xhr = this.sync('</span><span class="ruby-identifier">delete</span><span class="ruby-string">', this, options);
    if (!options.wait) destroy();
    return xhr;
  },

  // Default URL for the model'</span><span class="ruby-identifier">s</span> <span class="ruby-identifier">representation</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">server</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">you</span><span class="ruby-string">'re
  // using Backbone'</span><span class="ruby-identifier">s</span> <span class="ruby-identifier">restful</span> <span class="ruby-identifier">methods</span>, <span class="ruby-identifier">override</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">change</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">endpoint</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">will</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">called</span>.
  <span class="ruby-identifier">url</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">base</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">result</span>(<span class="ruby-identifier">this</span>, <span class="ruby-string">'urlRoot'</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">_</span>.<span class="ruby-identifier">result</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">collection</span>, <span class="ruby-string">'url'</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">urlError</span>();
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isNew</span>()) <span class="ruby-keyword">return</span> <span class="ruby-identifier">base</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">base</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">base</span>.<span class="ruby-identifier">charAt</span>(<span class="ruby-identifier">base</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) <span class="ruby-operator">===</span> <span class="ruby-string">'/'</span> <span class="ruby-operator">?</span> <span class="ruby-string">''</span> <span class="ruby-operator">:</span> <span class="ruby-string">'/'</span>) <span class="ruby-operator">+</span> <span class="ruby-identifier">encodeURIComponent</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">id</span>);
  },

  <span class="ruby-regexp">//</span> <span class="ruby-operator">**</span><span class="ruby-identifier">parse</span><span class="ruby-operator">**</span> <span class="ruby-identifier">converts</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">response</span> <span class="ruby-identifier">into</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">hash</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">attributes</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">be</span> <span class="ruby-value">%xset`</span> <span class="ruby-identifier">on</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">model</span>. <span class="ruby-constant">The</span> <span class="ruby-identifier">default</span> <span class="ruby-identifier">implementation</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">just</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">pass</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">response</span> <span class="ruby-identifier">along</span>.
  <span class="ruby-identifier">parse</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">resp</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">resp</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Create</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">new</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">identical</span> <span class="ruby-identifier">attributes</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">one</span>.
  <span class="ruby-identifier">clone</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">constructor</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">attributes</span>);
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">A</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">new</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">has</span> <span class="ruby-identifier">never</span> <span class="ruby-identifier">been</span> <span class="ruby-identifier">saved</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">server</span>, <span class="ruby-keyword">and</span> <span class="ruby-identifier">lacks</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">id</span>.
  <span class="ruby-identifier">isNew</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">id</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Check</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">currently</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">valid</span> <span class="ruby-identifier">state</span>.
  <span class="ruby-identifier">isValid</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">options</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_validate</span>({}, <span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-identifier">options</span> <span class="ruby-operator">||</span> {}, { <span class="ruby-identifier">validate</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span> }));
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Run</span> <span class="ruby-identifier">validation</span> <span class="ruby-identifier">against</span> <span class="ruby-identifier">the</span> <span class="ruby-keyword">next</span> <span class="ruby-identifier">complete</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">attributes</span>,
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">returning</span> <span class="ruby-value">%xtrue`</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">all</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">well</span>. <span class="ruby-constant">Otherwise</span>, <span class="ruby-identifier">fire</span> <span class="ruby-identifier">an</span> <span class="ruby-value">%x&quot;invalid&quot;`</span> <span class="ruby-identifier">event</span>.
  <span class="ruby-identifier">_validate</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">attrs</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">options</span>.<span class="ruby-identifier">validate</span> <span class="ruby-operator">||</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">validate</span>) <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
    <span class="ruby-identifier">attrs</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>({}, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">attrs</span>);
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">error</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">validationError</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">validate</span>(<span class="ruby-identifier">attrs</span>, <span class="ruby-identifier">options</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">null</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">error</span>) <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">trigger</span>(<span class="ruby-string">'invalid'</span>, <span class="ruby-identifier">this</span>, <span class="ruby-identifier">error</span>, <span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-identifier">options</span> <span class="ruby-operator">||</span> {}, {<span class="ruby-identifier">validationError</span><span class="ruby-operator">:</span> <span class="ruby-identifier">error</span>}));
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
  }

});

<span class="ruby-regexp">//</span> <span class="ruby-constant">Underscore</span> <span class="ruby-identifier">methods</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">we</span> <span class="ruby-identifier">want</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">implement</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">the</span> <span class="ruby-constant">Model</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">modelMethods</span> = [<span class="ruby-string">'keys'</span>, <span class="ruby-string">'values'</span>, <span class="ruby-string">'pairs'</span>, <span class="ruby-string">'invert'</span>, <span class="ruby-string">'pick'</span>, <span class="ruby-string">'omit'</span>];

<span class="ruby-regexp">//</span> <span class="ruby-constant">Mix</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">each</span> <span class="ruby-constant">Underscore</span> <span class="ruby-identifier">method</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">proxy</span> <span class="ruby-identifier">to</span> <span class="ruby-node">%xModel#attributes`</span>.
<span class="ruby-identifier">_</span>.<span class="ruby-identifier">each</span>(<span class="ruby-identifier">modelMethods</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">method</span>) {
  <span class="ruby-constant">Model</span>.<span class="ruby-identifier">prototype</span>[<span class="ruby-identifier">method</span>] = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">args</span> = <span class="ruby-identifier">slice</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">arguments</span>);
    <span class="ruby-identifier">args</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">attributes</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">_</span>[<span class="ruby-identifier">method</span>].<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">_</span>, <span class="ruby-identifier">args</span>);
  };
});

<span class="ruby-regexp">//</span> <span class="ruby-constant">Backbone</span>.<span class="ruby-constant">Collection</span>
<span class="ruby-regexp">//</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span>

<span class="ruby-regexp">//</span> <span class="ruby-constant">If</span> <span class="ruby-identifier">models</span> <span class="ruby-identifier">tend</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">represent</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">single</span> <span class="ruby-identifier">row</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">data</span>, <span class="ruby-identifier">a</span> <span class="ruby-constant">Backbone</span> <span class="ruby-constant">Collection</span> <span class="ruby-identifier">is</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">more</span> <span class="ruby-identifier">analagous</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">table</span> <span class="ruby-identifier">full</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">data</span> <span class="ruby-operator">...</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">small</span> <span class="ruby-identifier">slice</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">page</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">that</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">table</span>, <span class="ruby-keyword">or</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">collection</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">rows</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">belong</span> <span class="ruby-identifier">together</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">particular</span> <span class="ruby-identifier">reason</span>
<span class="ruby-regexp">//</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span> <span class="ruby-identifier">all</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">messages</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">particular</span> <span class="ruby-identifier">folder</span>, <span class="ruby-identifier">all</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">documents</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">belonging</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">particular</span> <span class="ruby-identifier">author</span>, <span class="ruby-keyword">and</span> <span class="ruby-identifier">so</span> <span class="ruby-identifier">on</span>. <span class="ruby-constant">Collections</span> <span class="ruby-identifier">maintain</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">indexes</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">their</span> <span class="ruby-identifier">models</span>, <span class="ruby-identifier">both</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">order</span>, <span class="ruby-keyword">and</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">lookup</span> <span class="ruby-identifier">by</span> <span class="ruby-value">%xid`</span>.

<span class="ruby-operator">/</span><span class="ruby-regexp">/ Create a new **Collection**, perhaps to contain a specific type of `model`.
/</span><span class="ruby-operator">/</span> <span class="ruby-constant">If</span> <span class="ruby-identifier">a</span> <span class="ruby-value">%xcomparator`</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">specified</span>, <span class="ruby-identifier">the</span> <span class="ruby-constant">Collection</span> <span class="ruby-identifier">will</span> <span class="ruby-identifier">maintain</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">its</span> <span class="ruby-identifier">models</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">sort</span> <span class="ruby-identifier">order</span>, <span class="ruby-identifier">as</span> <span class="ruby-identifier">they</span><span class="ruby-string">'re added and removed.
var Collection = Backbone.Collection = function(models, options) {
  options || (options = {});
  if (options.url) this.url = options.url;
  if (options.model) this.model = options.model;
  if (options.comparator !== void 0) this.comparator = options.comparator;
  this._reset();
  this.initialize.apply(this, arguments);
  if (models) this.reset(models, _.extend({silent: true}, options));
};

// Default options for `Collection#set`.
var setOptions = {add: true, remove: true, merge: true};
var addOptions = {add: true, merge: false, remove: false};

// Define the Collection'</span><span class="ruby-identifier">s</span> <span class="ruby-identifier">inheritable</span> <span class="ruby-identifier">methods</span>.
<span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">Collection</span>.<span class="ruby-identifier">prototype</span>, <span class="ruby-constant">Events</span>, {

  <span class="ruby-regexp">//</span> <span class="ruby-constant">The</span> <span class="ruby-identifier">default</span> <span class="ruby-identifier">model</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">collection</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">just</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">**</span><span class="ruby-constant">Backbone</span>.<span class="ruby-constant">Model</span><span class="ruby-operator">**</span>.
  <span class="ruby-operator">/</span><span class="ruby-regexp">/ This should be overridden in most cases.
  model: Model,

  /</span><span class="ruby-operator">/</span> <span class="ruby-constant">Initialize</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">empty</span> <span class="ruby-identifier">function</span> <span class="ruby-identifier">by</span> <span class="ruby-identifier">default</span>. <span class="ruby-constant">Override</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">your</span> <span class="ruby-identifier">own</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">initialization</span> <span class="ruby-identifier">logic</span>.
  <span class="ruby-identifier">initialize</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(){},

  <span class="ruby-regexp">//</span> <span class="ruby-constant">The</span> <span class="ruby-constant">JSON</span> <span class="ruby-identifier">representation</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">a</span> <span class="ruby-constant">Collection</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">array</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">models</span><span class="ruby-string">' attributes.
  toJSON: function(options) {
    return this.map(function(model){ return model.toJSON(options); });
  },

  // Proxy `Backbone.sync` by default.
  sync: function() {
    return Backbone.sync.apply(this, arguments);
  },

  // Add a model, or list of models to the set.
  add: function(models, options) {
    return this.set(models, _.defaults(options || {}, addOptions));
  },

  // Remove a model, or a list of models from the set.
  remove: function(models, options) {
    models = _.isArray(models) ? models.slice() : [models];
    options || (options = {});
    var i, l, index, model;
    for (i = 0, l = models.length; i &lt; l; i++) {
      model = this.get(models[i]);
      if (!model) continue;
      delete this._byId[model.id];
      delete this._byId[model.cid];
      index = this.indexOf(model);
      this.models.splice(index, 1);
      this.length--;
      if (!options.silent) {
        options.index = index;
        model.trigger('</span><span class="ruby-identifier">remove</span><span class="ruby-string">', model, this, options);
      }
      this._removeReference(model);
    }
    return this;
  },

  // Update a collection by `set`-ing a new list of models, adding new ones,
  // removing models that are no longer present, and merging models that
  // already exist in the collection, as necessary. Similar to **Model#set**,
  // the core operation for updating the data contained by the collection.
  set: function(models, options) {
    options = _.defaults(options || {}, setOptions);
    if (options.parse) models = this.parse(models, options);
    if (!_.isArray(models)) models = models ? [models] : [];
    var i, l, model, attrs, existing, sort;
    var at = options.at;
    var sortable = this.comparator &amp;&amp; (at == null) &amp;&amp; options.sort !== false;
    var sortAttr = _.isString(this.comparator) ? this.comparator : null;
    var toAdd = [], toRemove = [], modelMap = {};

    // Turn bare objects into model references, and prevent invalid models
    // from being added.
    for (i = 0, l = models.length; i &lt; l; i++) {
      if (!(model = this._prepareModel(models[i], options))) continue;

      // If a duplicate is found, prevent it from being added and
      // optionally merge it into the existing model.
      if (existing = this.get(model)) {
        if (options.remove) modelMap[existing.cid] = true;
        if (options.merge) {
          existing.set(model.attributes, options);
          if (sortable &amp;&amp; !sort &amp;&amp; existing.hasChanged(sortAttr)) sort = true;
        }

      // This is a new model, push it to the `toAdd` list.
      } else if (options.add) {
        toAdd.push(model);

        // Listen to added models'</span> <span class="ruby-identifier">events</span>, <span class="ruby-keyword">and</span> <span class="ruby-identifier">index</span> <span class="ruby-identifier">models</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">lookup</span> <span class="ruby-identifier">by</span>
        <span class="ruby-regexp">//</span> <span class="ruby-value">%xid`</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">by</span> <span class="ruby-value">%xcid`</span>.
        <span class="ruby-identifier">model</span>.<span class="ruby-identifier">on</span>(<span class="ruby-string">'all'</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_onModelEvent</span>, <span class="ruby-identifier">this</span>);
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_byId</span>[<span class="ruby-identifier">model</span>.<span class="ruby-identifier">cid</span>] = <span class="ruby-identifier">model</span>;
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">model</span>.<span class="ruby-identifier">id</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span>) <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_byId</span>[<span class="ruby-identifier">model</span>.<span class="ruby-identifier">id</span>] = <span class="ruby-identifier">model</span>;
      }
    }

    <span class="ruby-regexp">//</span> <span class="ruby-constant">Remove</span> <span class="ruby-identifier">nonexistent</span> <span class="ruby-identifier">models</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">appropriate</span>.
    <span class="ruby-identifier">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">remove</span>) {
      <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">l</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">l</span>; <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">i</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">modelMap</span>[(<span class="ruby-identifier">model</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">models</span>[<span class="ruby-identifier">i</span>]).<span class="ruby-identifier">cid</span>]) <span class="ruby-identifier">toRemove</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">model</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">toRemove</span>.<span class="ruby-identifier">length</span>) <span class="ruby-identifier">this</span>.<span class="ruby-identifier">remove</span>(<span class="ruby-identifier">toRemove</span>, <span class="ruby-identifier">options</span>);
    }

    <span class="ruby-regexp">//</span> <span class="ruby-constant">See</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">sorting</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">needed</span>, <span class="ruby-identifier">update</span> <span class="ruby-value">%xlength`</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">splice</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">new</span> <span class="ruby-identifier">models</span>.
    <span class="ruby-identifier">if</span> (<span class="ruby-identifier">toAdd</span>.<span class="ruby-identifier">length</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">sortable</span>) <span class="ruby-identifier">sort</span> = <span class="ruby-keyword">true</span>;
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">toAdd</span>.<span class="ruby-identifier">length</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">at</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span>) {
        <span class="ruby-identifier">splice</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">models</span>, [<span class="ruby-identifier">at</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">toAdd</span>));
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">push</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">models</span>, <span class="ruby-identifier">toAdd</span>);
      }
    }

    <span class="ruby-regexp">//</span> <span class="ruby-constant">Silently</span> <span class="ruby-identifier">sort</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">collection</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">appropriate</span>.
    <span class="ruby-identifier">if</span> (<span class="ruby-identifier">sort</span>) <span class="ruby-identifier">this</span>.<span class="ruby-identifier">sort</span>({<span class="ruby-identifier">silent</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>});

    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">silent</span>) <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;

    <span class="ruby-regexp">//</span> <span class="ruby-constant">Trigger</span> <span class="ruby-value">%xadd`</span> <span class="ruby-identifier">events</span>.
    <span class="ruby-identifier">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">l</span> = <span class="ruby-identifier">toAdd</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">l</span>; <span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      (<span class="ruby-identifier">model</span> = <span class="ruby-identifier">toAdd</span>[<span class="ruby-identifier">i</span>]).<span class="ruby-identifier">trigger</span>(<span class="ruby-string">'add'</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">this</span>, <span class="ruby-identifier">options</span>);
    }

    <span class="ruby-regexp">//</span> <span class="ruby-constant">Trigger</span> <span class="ruby-value">%xsort`</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">collection</span> <span class="ruby-identifier">was</span> <span class="ruby-identifier">sorted</span>.
    <span class="ruby-identifier">if</span> (<span class="ruby-identifier">sort</span>) <span class="ruby-identifier">this</span>.<span class="ruby-identifier">trigger</span>(<span class="ruby-string">'sort'</span>, <span class="ruby-identifier">this</span>, <span class="ruby-identifier">options</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">When</span> <span class="ruby-identifier">you</span> <span class="ruby-identifier">have</span> <span class="ruby-identifier">more</span> <span class="ruby-identifier">items</span> <span class="ruby-identifier">than</span> <span class="ruby-identifier">you</span> <span class="ruby-identifier">want</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">add</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">remove</span> <span class="ruby-identifier">individually</span>,
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">you</span> <span class="ruby-identifier">can</span> <span class="ruby-identifier">reset</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">entire</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">new</span> <span class="ruby-identifier">list</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">models</span>, <span class="ruby-identifier">without</span> <span class="ruby-identifier">firing</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">any</span> <span class="ruby-identifier">granular</span> <span class="ruby-value">%xadd`</span> <span class="ruby-keyword">or</span> <span class="ruby-value">%xremove`</span> <span class="ruby-identifier">events</span>. <span class="ruby-constant">Fires</span> <span class="ruby-value">%xreset`</span> <span class="ruby-keyword">when</span> <span class="ruby-identifier">finished</span>.
  <span class="ruby-operator">/</span><span class="ruby-regexp">/ Useful for bulk operations and optimizations.
  reset: function(models, options) {
    options || (options = {});
    for (var i = 0, l = this.models.length; i &lt; l; i++) {
      this._removeReference(this.models[i]);
    }
    options.previousModels = this.models;
    this._reset();
    this.add(models, _.extend({silent: true}, options));
    if (!options.silent) this.trigger('reset', this, options);
    return this;
  },

  /</span><span class="ruby-operator">/</span> <span class="ruby-constant">Add</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-keyword">end</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">collection</span>.
  <span class="ruby-identifier">push</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-identifier">model</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_prepareModel</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">options</span>);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>({<span class="ruby-identifier">at</span><span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">length</span>}, <span class="ruby-identifier">options</span>));
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">model</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Remove</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">from</span> <span class="ruby-identifier">the</span> <span class="ruby-keyword">end</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">collection</span>.
  <span class="ruby-identifier">pop</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">options</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">model</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">at</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">remove</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">options</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">model</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Add</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">beginning</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">collection</span>.
  <span class="ruby-identifier">unshift</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-identifier">model</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_prepareModel</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">options</span>);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>({<span class="ruby-identifier">at</span><span class="ruby-operator">:</span> <span class="ruby-value">0</span>}, <span class="ruby-identifier">options</span>));
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">model</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Remove</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">from</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">beginning</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">collection</span>.
  <span class="ruby-identifier">shift</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">options</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">model</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">remove</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">options</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">model</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Slice</span> <span class="ruby-identifier">out</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">sub</span><span class="ruby-operator">-</span><span class="ruby-identifier">array</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">models</span> <span class="ruby-identifier">from</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">collection</span>.
  <span class="ruby-identifier">slice</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-keyword">begin</span>, <span class="ruby-keyword">end</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">models</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-keyword">begin</span>, <span class="ruby-keyword">end</span>);
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Get</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">from</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">by</span> <span class="ruby-identifier">id</span>.
  <span class="ruby-identifier">get</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">obj</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">obj</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) <span class="ruby-keyword">return</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_byId</span>[<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">id</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">id</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">cid</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">obj</span>];
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Get</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">at</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">given</span> <span class="ruby-identifier">index</span>.
  <span class="ruby-identifier">at</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">index</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">models</span>[<span class="ruby-identifier">index</span>];
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Return</span> <span class="ruby-identifier">models</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">matching</span> <span class="ruby-identifier">attributes</span>. <span class="ruby-constant">Useful</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">simple</span> <span class="ruby-identifier">cases</span> <span class="ruby-identifier">of</span>
  <span class="ruby-regexp">//</span> <span class="ruby-value">%xfilter`</span>.
  <span class="ruby-identifier">where</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">attrs</span>, <span class="ruby-identifier">first</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">_</span>.<span class="ruby-identifier">isEmpty</span>(<span class="ruby-identifier">attrs</span>)) <span class="ruby-keyword">return</span> <span class="ruby-identifier">first</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> [];
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>[<span class="ruby-identifier">first</span> <span class="ruby-operator">?</span> <span class="ruby-string">'find'</span> <span class="ruby-operator">:</span> <span class="ruby-string">'filter'</span>](<span class="ruby-identifier">function</span>(<span class="ruby-identifier">model</span>) {
      <span class="ruby-keyword">for</span> (<span class="ruby-identifier">var</span> <span class="ruby-identifier">key</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">attrs</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">attrs</span>[<span class="ruby-identifier">key</span>] <span class="ruby-operator">!=</span>= <span class="ruby-identifier">model</span>.<span class="ruby-identifier">get</span>(<span class="ruby-identifier">key</span>)) <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
      }
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
    });
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Return</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">first</span> <span class="ruby-identifier">model</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">matching</span> <span class="ruby-identifier">attributes</span>. <span class="ruby-constant">Useful</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">simple</span> <span class="ruby-identifier">cases</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">of</span> <span class="ruby-value">%xfind`</span>.
  <span class="ruby-identifier">findWhere</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">attrs</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">attrs</span>, <span class="ruby-keyword">true</span>);
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Force</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">collection</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">re</span><span class="ruby-operator">-</span><span class="ruby-identifier">sort</span> <span class="ruby-identifier">itself</span>. <span class="ruby-constant">You</span> <span class="ruby-identifier">don</span><span class="ruby-string">'t need to call this under
  // normal circumstances, as the set will maintain sort order as each item
  // is added.
  sort: function(options) {
    if (!this.comparator) throw new Error('</span><span class="ruby-constant">Cannot</span> <span class="ruby-identifier">sort</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">without</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">comparator</span><span class="ruby-string">');
    options || (options = {});

    // Run sort based on type of `comparator`.
    if (_.isString(this.comparator) || this.comparator.length === 1) {
      this.models = this.sortBy(this.comparator, this);
    } else {
      this.models.sort(_.bind(this.comparator, this));
    }

    if (!options.silent) this.trigger('</span><span class="ruby-identifier">sort</span><span class="ruby-string">', this, options);
    return this;
  },

  // Figure out the smallest index at which a model should be inserted so as
  // to maintain order.
  sortedIndex: function(model, value, context) {
    value || (value = this.comparator);
    var iterator = _.isFunction(value) ? value : function(model) {
      return model.get(value);
    };
    return _.sortedIndex(this.models, model, iterator, context);
  },

  // Pluck an attribute from each model in the collection.
  pluck: function(attr) {
    return _.invoke(this.models, '</span><span class="ruby-identifier">get</span><span class="ruby-string">', attr);
  },

  // Fetch the default set of models for this collection, resetting the
  // collection when they arrive. If `reset: true` is passed, the response
  // data will be passed through the `reset` method instead of `set`.
  fetch: function(options) {
    options = options ? _.clone(options) : {};
    if (options.parse === void 0) options.parse = true;
    var success = options.success;
    var collection = this;
    options.success = function(resp) {
      var method = options.reset ? '</span><span class="ruby-identifier">reset</span><span class="ruby-string">' : '</span><span class="ruby-identifier">set</span><span class="ruby-string">';
      collection[method](resp, options);
      if (success) success(collection, resp, options);
      collection.trigger('</span><span class="ruby-identifier">sync</span><span class="ruby-string">', collection, resp, options);
    };
    wrapError(this, options);
    return this.sync('</span><span class="ruby-identifier">read</span><span class="ruby-string">', this, options);
  },

  // Create a new instance of a model in this collection. Add the model to the
  // collection immediately, unless `wait: true` is passed, in which case we
  // wait for the server to agree.
  create: function(model, options) {
    options = options ? _.clone(options) : {};
    if (!(model = this._prepareModel(model, options))) return false;
    if (!options.wait) this.add(model, options);
    var collection = this;
    var success = options.success;
    options.success = function(resp) {
      if (options.wait) collection.add(model, options);
      if (success) success(model, resp, options);
    };
    model.save(null, options);
    return model;
  },

  // **parse** converts a response into a list of models to be added to the
  // collection. The default implementation is just to pass it through.
  parse: function(resp, options) {
    return resp;
  },

  // Create a new collection with an identical list of models as this one.
  clone: function() {
    return new this.constructor(this.models);
  },

  // Private method to reset all internal state. Called when the collection
  // is first initialized or reset.
  _reset: function() {
    this.length = 0;
    this.models = [];
    this._byId  = {};
  },

  // Prepare a hash of attributes (or other model) to be added to this
  // collection.
  _prepareModel: function(attrs, options) {
    if (attrs instanceof Model) {
      if (!attrs.collection) attrs.collection = this;
      return attrs;
    }
    options || (options = {});
    options.collection = this;
    var model = new this.model(attrs, options);
    if (!model._validate(attrs, options)) {
      this.trigger('</span><span class="ruby-identifier">invalid</span><span class="ruby-string">', this, attrs, options);
      return false;
    }
    return model;
  },

  // Internal method to sever a model'</span><span class="ruby-identifier">s</span> <span class="ruby-identifier">ties</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">collection</span>.
  <span class="ruby-identifier">_removeReference</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">model</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">model</span>.<span class="ruby-identifier">collection</span>) <span class="ruby-identifier">delete</span> <span class="ruby-identifier">model</span>.<span class="ruby-identifier">collection</span>;
    <span class="ruby-identifier">model</span>.<span class="ruby-identifier">off</span>(<span class="ruby-string">'all'</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_onModelEvent</span>, <span class="ruby-identifier">this</span>);
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Internal</span> <span class="ruby-identifier">method</span> <span class="ruby-identifier">called</span> <span class="ruby-identifier">every</span> <span class="ruby-identifier">time</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">model</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">fires</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">event</span>.
  <span class="ruby-operator">/</span><span class="ruby-regexp">/ Sets need to update their indexes when models change ids. All other
  /</span><span class="ruby-operator">/</span> <span class="ruby-identifier">events</span> <span class="ruby-identifier">simply</span> <span class="ruby-identifier">proxy</span> <span class="ruby-identifier">through</span>. <span class="ruby-string">&quot;add&quot;</span> <span class="ruby-keyword">and</span> <span class="ruby-string">&quot;remove&quot;</span> <span class="ruby-identifier">events</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">originate</span>
  <span class="ruby-regexp">//</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">other</span> <span class="ruby-identifier">collections</span> <span class="ruby-identifier">are</span> <span class="ruby-identifier">ignored</span>.
  <span class="ruby-identifier">_onModelEvent</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">event</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">collection</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">event</span> <span class="ruby-operator">===</span> <span class="ruby-string">'add'</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">event</span> <span class="ruby-operator">===</span> <span class="ruby-string">'remove'</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">collection</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">this</span>) <span class="ruby-keyword">return</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">event</span> <span class="ruby-operator">===</span> <span class="ruby-string">'destroy'</span>) <span class="ruby-identifier">this</span>.<span class="ruby-identifier">remove</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">options</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">model</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">event</span> <span class="ruby-operator">===</span> <span class="ruby-string">'change:'</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">model</span>.<span class="ruby-identifier">idAttribute</span>) {
      <span class="ruby-identifier">delete</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_byId</span>[<span class="ruby-identifier">model</span>.<span class="ruby-identifier">previous</span>(<span class="ruby-identifier">model</span>.<span class="ruby-identifier">idAttribute</span>)];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">model</span>.<span class="ruby-identifier">id</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span>) <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_byId</span>[<span class="ruby-identifier">model</span>.<span class="ruby-identifier">id</span>] = <span class="ruby-identifier">model</span>;
    }
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">trigger</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
  }

});

<span class="ruby-regexp">//</span> <span class="ruby-constant">Underscore</span> <span class="ruby-identifier">methods</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">we</span> <span class="ruby-identifier">want</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">implement</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">the</span> <span class="ruby-constant">Collection</span>.
<span class="ruby-operator">/</span><span class="ruby-regexp">/ 90% of the core usefulness of Backbone Collections is actually implemented
/</span><span class="ruby-operator">/</span> <span class="ruby-identifier">right</span> <span class="ruby-identifier">here</span><span class="ruby-operator">:</span>
<span class="ruby-identifier">var</span> <span class="ruby-identifier">methods</span> = [<span class="ruby-string">'forEach'</span>, <span class="ruby-string">'each'</span>, <span class="ruby-string">'map'</span>, <span class="ruby-string">'collect'</span>, <span class="ruby-string">'reduce'</span>, <span class="ruby-string">'foldl'</span>,
  <span class="ruby-string">'inject'</span>, <span class="ruby-string">'reduceRight'</span>, <span class="ruby-string">'foldr'</span>, <span class="ruby-string">'find'</span>, <span class="ruby-string">'detect'</span>, <span class="ruby-string">'filter'</span>, <span class="ruby-string">'select'</span>,
  <span class="ruby-string">'reject'</span>, <span class="ruby-string">'every'</span>, <span class="ruby-string">'all'</span>, <span class="ruby-string">'some'</span>, <span class="ruby-string">'any'</span>, <span class="ruby-string">'include'</span>, <span class="ruby-string">'contains'</span>, <span class="ruby-string">'invoke'</span>,
  <span class="ruby-string">'max'</span>, <span class="ruby-string">'min'</span>, <span class="ruby-string">'toArray'</span>, <span class="ruby-string">'size'</span>, <span class="ruby-string">'first'</span>, <span class="ruby-string">'head'</span>, <span class="ruby-string">'take'</span>, <span class="ruby-string">'initial'</span>, <span class="ruby-string">'rest'</span>,
  <span class="ruby-string">'tail'</span>, <span class="ruby-string">'drop'</span>, <span class="ruby-string">'last'</span>, <span class="ruby-string">'without'</span>, <span class="ruby-string">'indexOf'</span>, <span class="ruby-string">'shuffle'</span>, <span class="ruby-string">'lastIndexOf'</span>,
  <span class="ruby-string">'isEmpty'</span>, <span class="ruby-string">'chain'</span>];

<span class="ruby-regexp">//</span> <span class="ruby-constant">Mix</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">each</span> <span class="ruby-constant">Underscore</span> <span class="ruby-identifier">method</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">proxy</span> <span class="ruby-identifier">to</span> <span class="ruby-node">%xCollection#models`</span>.
<span class="ruby-identifier">_</span>.<span class="ruby-identifier">each</span>(<span class="ruby-identifier">methods</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">method</span>) {
  <span class="ruby-constant">Collection</span>.<span class="ruby-identifier">prototype</span>[<span class="ruby-identifier">method</span>] = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">args</span> = <span class="ruby-identifier">slice</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">arguments</span>);
    <span class="ruby-identifier">args</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">models</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">_</span>[<span class="ruby-identifier">method</span>].<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">_</span>, <span class="ruby-identifier">args</span>);
  };
});

<span class="ruby-regexp">//</span> <span class="ruby-constant">Underscore</span> <span class="ruby-identifier">methods</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">take</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">property</span> <span class="ruby-identifier">name</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">argument</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">attributeMethods</span> = [<span class="ruby-string">'groupBy'</span>, <span class="ruby-string">'countBy'</span>, <span class="ruby-string">'sortBy'</span>];

<span class="ruby-regexp">//</span> <span class="ruby-constant">Use</span> <span class="ruby-identifier">attributes</span> <span class="ruby-identifier">instead</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">properties</span>.
<span class="ruby-identifier">_</span>.<span class="ruby-identifier">each</span>(<span class="ruby-identifier">attributeMethods</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">method</span>) {
  <span class="ruby-constant">Collection</span>.<span class="ruby-identifier">prototype</span>[<span class="ruby-identifier">method</span>] = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">context</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">iterator</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">isFunction</span>(<span class="ruby-identifier">value</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">model</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">model</span>.<span class="ruby-identifier">get</span>(<span class="ruby-identifier">value</span>);
    };
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">_</span>[<span class="ruby-identifier">method</span>](<span class="ruby-identifier">this</span>.<span class="ruby-identifier">models</span>, <span class="ruby-identifier">iterator</span>, <span class="ruby-identifier">context</span>);
  };
});

<span class="ruby-regexp">//</span> <span class="ruby-constant">Backbone</span>.<span class="ruby-constant">View</span>
<span class="ruby-regexp">//</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span>

<span class="ruby-regexp">//</span> <span class="ruby-constant">Backbone</span> <span class="ruby-constant">Views</span> <span class="ruby-identifier">are</span> <span class="ruby-identifier">almost</span> <span class="ruby-identifier">more</span> <span class="ruby-identifier">convention</span> <span class="ruby-identifier">than</span> <span class="ruby-identifier">they</span> <span class="ruby-identifier">are</span> <span class="ruby-identifier">actual</span> <span class="ruby-identifier">code</span>. <span class="ruby-constant">A</span> <span class="ruby-constant">View</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">simply</span> <span class="ruby-identifier">a</span> <span class="ruby-constant">JavaScript</span> <span class="ruby-identifier">object</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">represents</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">logical</span> <span class="ruby-identifier">chunk</span> <span class="ruby-identifier">of</span> <span class="ruby-constant">UI</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">the</span>
<span class="ruby-regexp">//</span> <span class="ruby-constant">DOM</span>. <span class="ruby-constant">This</span> <span class="ruby-identifier">might</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">single</span> <span class="ruby-identifier">item</span>, <span class="ruby-identifier">an</span> <span class="ruby-identifier">entire</span> <span class="ruby-identifier">list</span>, <span class="ruby-identifier">a</span> <span class="ruby-identifier">sidebar</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">panel</span>, <span class="ruby-keyword">or</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">even</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">surrounding</span> <span class="ruby-identifier">frame</span> <span class="ruby-identifier">which</span> <span class="ruby-identifier">wraps</span> <span class="ruby-identifier">your</span> <span class="ruby-identifier">whole</span> <span class="ruby-identifier">app</span>. <span class="ruby-constant">Defining</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">chunk</span> <span class="ruby-identifier">of</span>
<span class="ruby-regexp">//</span> <span class="ruby-constant">UI</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">**</span><span class="ruby-constant">View</span><span class="ruby-operator">**</span> <span class="ruby-identifier">allows</span> <span class="ruby-identifier">you</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">define</span> <span class="ruby-identifier">your</span> <span class="ruby-constant">DOM</span> <span class="ruby-identifier">events</span> <span class="ruby-identifier">declaratively</span>, <span class="ruby-identifier">without</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">having</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">worry</span> <span class="ruby-identifier">about</span> <span class="ruby-identifier">render</span> <span class="ruby-identifier">order</span> <span class="ruby-operator">...</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">makes</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">easy</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">view</span> <span class="ruby-identifier">to</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">react</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">specific</span> <span class="ruby-identifier">changes</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">state</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">your</span> <span class="ruby-identifier">models</span>.

<span class="ruby-operator">/</span><span class="ruby-regexp">/ Creating a Backbone.View creates its initial element outside of the DOM,
/</span><span class="ruby-operator">/</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">existing</span> <span class="ruby-identifier">element</span> <span class="ruby-identifier">is</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">provided</span><span class="ruby-operator">...</span>
<span class="ruby-identifier">var</span> <span class="ruby-constant">View</span> = <span class="ruby-constant">Backbone</span>.<span class="ruby-constant">View</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">options</span>) {
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cid</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">uniqueId</span>(<span class="ruby-string">'view'</span>);
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_configure</span>(<span class="ruby-identifier">options</span> <span class="ruby-operator">||</span> {});
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_ensureElement</span>();
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">initialize</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">delegateEvents</span>();
};

<span class="ruby-regexp">//</span> <span class="ruby-constant">Cached</span> <span class="ruby-identifier">regex</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">split</span> <span class="ruby-identifier">keys</span> <span class="ruby-keyword">for</span> <span class="ruby-value">%xdelegate`</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">delegateEventSplitter</span> = <span class="ruby-regexp">/^(\S+)\s*(.*)$/</span>;

<span class="ruby-regexp">//</span> <span class="ruby-constant">List</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">view</span> <span class="ruby-identifier">options</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">merged</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">properties</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">viewOptions</span> = [<span class="ruby-string">'model'</span>, <span class="ruby-string">'collection'</span>, <span class="ruby-string">'el'</span>, <span class="ruby-string">'id'</span>, <span class="ruby-string">'attributes'</span>, <span class="ruby-string">'className'</span>, <span class="ruby-string">'tagName'</span>, <span class="ruby-string">'events'</span>];

<span class="ruby-regexp">//</span> <span class="ruby-constant">Set</span> <span class="ruby-identifier">up</span> <span class="ruby-identifier">all</span> <span class="ruby-identifier">inheritable</span> <span class="ruby-operator">**</span><span class="ruby-constant">Backbone</span>.<span class="ruby-constant">View</span><span class="ruby-operator">**</span> <span class="ruby-identifier">properties</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">methods</span>.
<span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">View</span>.<span class="ruby-identifier">prototype</span>, <span class="ruby-constant">Events</span>, {

  <span class="ruby-regexp">//</span> <span class="ruby-constant">The</span> <span class="ruby-identifier">default</span> <span class="ruby-value">%xtagName`</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">a</span> <span class="ruby-constant">View</span><span class="ruby-string">'s element is `&quot;div&quot;`.
  tagName: '</span><span class="ruby-identifier">div</span><span class="ruby-string">',

  // jQuery delegate for element lookup, scoped to DOM elements within the
  // current view. This should be prefered to global lookups where possible.
  $: function(selector) {
    return this.$el.find(selector);
  },

  // Initialize is an empty function by default. Override it with your own
  // initialization logic.
  initialize: function(){},

  // **render** is the core function that your view should override, in order
  // to populate its element (`this.el`), with the appropriate HTML. The
  // convention is for **render** to always return `this`.
  render: function() {
    return this;
  },

  // Remove this view by taking the element out of the DOM, and removing any
  // applicable Backbone.Events listeners.
  remove: function() {
    this.$el.remove();
    this.stopListening();
    return this;
  },

  // Change the view'</span><span class="ruby-identifier">s</span> <span class="ruby-identifier">element</span> (<span class="ruby-value">%xthis.el`</span> <span class="ruby-identifier">property</span>), <span class="ruby-identifier">including</span> <span class="ruby-identifier">event</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">re</span><span class="ruby-operator">-</span><span class="ruby-identifier">delegation</span>.
  <span class="ruby-identifier">setElement</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">element</span>, <span class="ruby-identifier">delegate</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">$el</span>) <span class="ruby-identifier">this</span>.<span class="ruby-identifier">undelegateEvents</span>();
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">$el</span> = <span class="ruby-identifier">element</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Backbone</span>.$ <span class="ruby-operator">?</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">:</span> <span class="ruby-constant">Backbone</span>.$(<span class="ruby-identifier">element</span>);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">el</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">$el</span>[<span class="ruby-value">0</span>];
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">delegate</span> <span class="ruby-operator">!=</span>= <span class="ruby-keyword">false</span>) <span class="ruby-identifier">this</span>.<span class="ruby-identifier">delegateEvents</span>();
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Set</span> <span class="ruby-identifier">callbacks</span>, <span class="ruby-identifier">where</span> <span class="ruby-value">%xthis.events`</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">hash</span> <span class="ruby-identifier">of</span>
  <span class="ruby-regexp">//</span>
  <span class="ruby-regexp">//</span> <span class="ruby-operator">*</span>{<span class="ruby-string">&quot;event selector&quot;</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;callback&quot;</span>}<span class="ruby-operator">*</span>
  <span class="ruby-regexp">//</span>
  <span class="ruby-regexp">//</span>     {
  <span class="ruby-regexp">//</span>       <span class="ruby-string">'mousedown .title'</span><span class="ruby-operator">:</span>  <span class="ruby-string">'edit'</span>,
  <span class="ruby-regexp">//</span>       <span class="ruby-string">'click .button'</span><span class="ruby-operator">:</span>     <span class="ruby-string">'save'</span>
  <span class="ruby-regexp">//</span>       <span class="ruby-string">'click .open'</span><span class="ruby-operator">:</span>       <span class="ruby-identifier">function</span>(<span class="ruby-identifier">e</span>) { <span class="ruby-operator">...</span> }
  <span class="ruby-regexp">//</span>     }
  <span class="ruby-regexp">//</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">pairs</span>. <span class="ruby-constant">Callbacks</span> <span class="ruby-identifier">will</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">bound</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">view</span>, <span class="ruby-identifier">with</span> <span class="ruby-value">%xthis`</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">properly</span>.
  <span class="ruby-operator">/</span><span class="ruby-regexp">/ Uses event delegation for efficiency.
  /</span><span class="ruby-operator">/</span> <span class="ruby-constant">Omitting</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">selector</span> <span class="ruby-identifier">binds</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">event</span> <span class="ruby-identifier">to</span> <span class="ruby-value">%xthis.el`</span>.
  <span class="ruby-operator">/</span><span class="ruby-regexp">/ This only works for delegate-able events: not `focus`, `blur`, and
  /</span><span class="ruby-operator">/</span> <span class="ruby-keyword">not</span> <span class="ruby-value">%xchange`</span>, <span class="ruby-value">%xsubmit`</span>, <span class="ruby-keyword">and</span> <span class="ruby-value">%xreset`</span> <span class="ruby-keyword">in</span> <span class="ruby-constant">Internet</span> <span class="ruby-constant">Explorer</span>.
  <span class="ruby-identifier">delegateEvents</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">events</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">events</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">events</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">result</span>(<span class="ruby-identifier">this</span>, <span class="ruby-string">'events'</span>)))) <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">undelegateEvents</span>();
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">var</span> <span class="ruby-identifier">key</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">events</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">method</span> = <span class="ruby-identifier">events</span>[<span class="ruby-identifier">key</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">_</span>.<span class="ruby-identifier">isFunction</span>(<span class="ruby-identifier">method</span>)) <span class="ruby-identifier">method</span> = <span class="ruby-identifier">this</span>[<span class="ruby-identifier">events</span>[<span class="ruby-identifier">key</span>]];
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">method</span>) <span class="ruby-identifier">continue</span>;

      <span class="ruby-identifier">var</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">key</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">delegateEventSplitter</span>);
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">eventName</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">selector</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>];
      <span class="ruby-identifier">method</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">bind</span>(<span class="ruby-identifier">method</span>, <span class="ruby-identifier">this</span>);
      <span class="ruby-identifier">eventName</span> <span class="ruby-operator">+=</span> <span class="ruby-string">'.delegateEvents'</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cid</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">selector</span> <span class="ruby-operator">===</span> <span class="ruby-string">''</span>) {
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">$el</span>.<span class="ruby-identifier">on</span>(<span class="ruby-identifier">eventName</span>, <span class="ruby-identifier">method</span>);
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">$el</span>.<span class="ruby-identifier">on</span>(<span class="ruby-identifier">eventName</span>, <span class="ruby-identifier">selector</span>, <span class="ruby-identifier">method</span>);
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Clears</span> <span class="ruby-identifier">all</span> <span class="ruby-identifier">callbacks</span> <span class="ruby-identifier">previously</span> <span class="ruby-identifier">bound</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">view</span> <span class="ruby-identifier">with</span> <span class="ruby-value">%xdelegateEvents`</span>.
  <span class="ruby-operator">/</span><span class="ruby-regexp">/ You usually don't need to use this, but may wish to if you have multiple
  /</span><span class="ruby-operator">/</span> <span class="ruby-constant">Backbone</span> <span class="ruby-identifier">views</span> <span class="ruby-identifier">attached</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">same</span> <span class="ruby-constant">DOM</span> <span class="ruby-identifier">element</span>.
  <span class="ruby-identifier">undelegateEvents</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">$el</span>.<span class="ruby-identifier">off</span>(<span class="ruby-string">'.delegateEvents'</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cid</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Performs</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">initial</span> <span class="ruby-identifier">configuration</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">a</span> <span class="ruby-constant">View</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">options</span>.
  <span class="ruby-operator">/</span><span class="ruby-regexp">/ Keys with special meaning *(e.g. model, collection, id, className)* are
  /</span><span class="ruby-operator">/</span> <span class="ruby-identifier">attached</span> <span class="ruby-identifier">directly</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">view</span>.  <span class="ruby-constant">See</span> <span class="ruby-value">%xviewOptions`</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">exhaustive</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">list</span>.
  <span class="ruby-identifier">_configure</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">options</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">options</span>) <span class="ruby-identifier">options</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>({}, <span class="ruby-identifier">_</span>.<span class="ruby-identifier">result</span>(<span class="ruby-identifier">this</span>, <span class="ruby-string">'options'</span>), <span class="ruby-identifier">options</span>);
    <span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">_</span>.<span class="ruby-identifier">pick</span>(<span class="ruby-identifier">options</span>, <span class="ruby-identifier">viewOptions</span>));
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">options</span> = <span class="ruby-identifier">options</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Ensure</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">the</span> <span class="ruby-constant">View</span> <span class="ruby-identifier">has</span> <span class="ruby-identifier">a</span> <span class="ruby-constant">DOM</span> <span class="ruby-identifier">element</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">render</span> <span class="ruby-identifier">into</span>.
  <span class="ruby-operator">/</span><span class="ruby-regexp">/ If `this.el` is a string, pass it through `$()`, take the first
  /</span><span class="ruby-operator">/</span> <span class="ruby-identifier">matching</span> <span class="ruby-identifier">element</span>, <span class="ruby-keyword">and</span> <span class="ruby-identifier">re</span><span class="ruby-operator">-</span><span class="ruby-identifier">assign</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">to</span> <span class="ruby-value">%xel`</span>. <span class="ruby-constant">Otherwise</span>, <span class="ruby-identifier">create</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">element</span> <span class="ruby-identifier">from</span> <span class="ruby-identifier">the</span> <span class="ruby-value">%xid`</span>, <span class="ruby-value">%xclassName`</span> <span class="ruby-keyword">and</span> <span class="ruby-value">%xtagName`</span> <span class="ruby-identifier">properties</span>.
  <span class="ruby-identifier">_ensureElement</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">el</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">attrs</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>({}, <span class="ruby-identifier">_</span>.<span class="ruby-identifier">result</span>(<span class="ruby-identifier">this</span>, <span class="ruby-string">'attributes'</span>));
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">id</span>) <span class="ruby-identifier">attrs</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">result</span>(<span class="ruby-identifier">this</span>, <span class="ruby-string">'id'</span>);
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">className</span>) <span class="ruby-identifier">attrs</span>[<span class="ruby-string">'class'</span>] = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">result</span>(<span class="ruby-identifier">this</span>, <span class="ruby-string">'className'</span>);
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">$el</span> = <span class="ruby-constant">Backbone</span>.$(<span class="ruby-string">'&lt;'</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">_</span>.<span class="ruby-identifier">result</span>(<span class="ruby-identifier">this</span>, <span class="ruby-string">'tagName'</span>) <span class="ruby-operator">+</span> <span class="ruby-string">'&gt;'</span>).<span class="ruby-identifier">attr</span>(<span class="ruby-identifier">attrs</span>);
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">setElement</span>(<span class="ruby-identifier">$el</span>, <span class="ruby-keyword">false</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">setElement</span>(<span class="ruby-identifier">_</span>.<span class="ruby-identifier">result</span>(<span class="ruby-identifier">this</span>, <span class="ruby-string">'el'</span>), <span class="ruby-keyword">false</span>);
    }
  }

});

<span class="ruby-regexp">//</span> <span class="ruby-constant">Backbone</span>.<span class="ruby-identifier">sync</span>
<span class="ruby-regexp">//</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span>

<span class="ruby-regexp">//</span> <span class="ruby-constant">Override</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">function</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">change</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">manner</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">which</span> <span class="ruby-constant">Backbone</span> <span class="ruby-identifier">persists</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">models</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">server</span>. <span class="ruby-constant">You</span> <span class="ruby-identifier">will</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">passed</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">type</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">request</span>, <span class="ruby-keyword">and</span> <span class="ruby-identifier">the</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">model</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">question</span>. <span class="ruby-constant">By</span> <span class="ruby-identifier">default</span>, <span class="ruby-identifier">makes</span> <span class="ruby-identifier">a</span> <span class="ruby-constant">RESTful</span> <span class="ruby-constant">Ajax</span> <span class="ruby-identifier">request</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">model</span><span class="ruby-string">'s `url()`. Some possible customizations could be:
//
// * Use `setTimeout` to batch rapid-fire updates into a single request.
// * Send up the models as XML instead of JSON.
// * Persist models via WebSockets instead of Ajax.
//
// Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
// as `POST`, with a `_method` parameter containing the true HTTP method,
// as well as all requests with the body as `application/x-www-form-urlencoded`
// instead of `application/json` with the model in a param named `model`.
// Useful when interfacing with server-side languages like **PHP** that make
// it difficult to read the body of `PUT` requests.
Backbone.sync = function(method, model, options) {
  var type = methodMap[method];

  // Default options, unless specified.
  _.defaults(options || (options = {}), {
    emulateHTTP: Backbone.emulateHTTP,
    emulateJSON: Backbone.emulateJSON
  });

  // Default JSON-request options.
  var params = {type: type, dataType: '</span><span class="ruby-identifier">json</span><span class="ruby-string">'};

  // Ensure that we have a URL.
  if (!options.url) {
    params.url = _.result(model, '</span><span class="ruby-identifier">url</span><span class="ruby-string">') || urlError();
  }

  // Ensure that we have the appropriate request data.
  if (options.data == null &amp;&amp; model &amp;&amp; (method === '</span><span class="ruby-identifier">create</span><span class="ruby-string">' || method === '</span><span class="ruby-identifier">update</span><span class="ruby-string">' || method === '</span><span class="ruby-identifier">patch</span><span class="ruby-string">')) {
    params.contentType = '</span><span class="ruby-identifier">application</span><span class="ruby-operator">/</span><span class="ruby-identifier">json</span><span class="ruby-string">';
    params.data = JSON.stringify(options.attrs || model.toJSON(options));
  }

  // For older servers, emulate JSON by encoding the request into an HTML-form.
  if (options.emulateJSON) {
    params.contentType = '</span><span class="ruby-identifier">application</span><span class="ruby-operator">/</span><span class="ruby-identifier">x</span><span class="ruby-operator">-</span><span class="ruby-identifier">www</span><span class="ruby-operator">-</span><span class="ruby-identifier">form</span><span class="ruby-operator">-</span><span class="ruby-identifier">urlencoded</span><span class="ruby-string">';
    params.data = params.data ? {model: params.data} : {};
  }

  // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
  // And an `X-HTTP-Method-Override` header.
  if (options.emulateHTTP &amp;&amp; (type === '</span><span class="ruby-constant">PUT</span><span class="ruby-string">' || type === '</span><span class="ruby-constant">DELETE</span><span class="ruby-string">' || type === '</span><span class="ruby-constant">PATCH</span><span class="ruby-string">')) {
    params.type = '</span><span class="ruby-constant">POST</span><span class="ruby-string">';
    if (options.emulateJSON) params.data._method = type;
    var beforeSend = options.beforeSend;
    options.beforeSend = function(xhr) {
      xhr.setRequestHeader('</span><span class="ruby-constant">X</span><span class="ruby-operator">-</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">-</span><span class="ruby-constant">Method</span><span class="ruby-operator">-</span><span class="ruby-constant">Override</span><span class="ruby-string">', type);
      if (beforeSend) return beforeSend.apply(this, arguments);
    };
  }

  // Don'</span><span class="ruby-identifier">t</span> <span class="ruby-identifier">process</span> <span class="ruby-identifier">data</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">non</span><span class="ruby-operator">-</span><span class="ruby-constant">GET</span> <span class="ruby-identifier">request</span>.
  <span class="ruby-identifier">if</span> (<span class="ruby-identifier">params</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">'GET'</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">options</span>.<span class="ruby-identifier">emulateJSON</span>) {
    <span class="ruby-identifier">params</span>.<span class="ruby-identifier">processData</span> = <span class="ruby-keyword">false</span>;
  }

  <span class="ruby-regexp">//</span> <span class="ruby-constant">If</span> <span class="ruby-identifier">we</span><span class="ruby-string">'re sending a `PATCH` request, and we'</span><span class="ruby-identifier">re</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">old</span> <span class="ruby-constant">Internet</span> <span class="ruby-constant">Explorer</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">still</span> <span class="ruby-identifier">has</span> <span class="ruby-constant">ActiveX</span> <span class="ruby-identifier">enabled</span> <span class="ruby-identifier">by</span> <span class="ruby-identifier">default</span>, <span class="ruby-identifier">override</span> <span class="ruby-identifier">jQuery</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">use</span> <span class="ruby-identifier">that</span>
  <span class="ruby-regexp">//</span> <span class="ruby-keyword">for</span> <span class="ruby-constant">XHR</span> <span class="ruby-identifier">instead</span>. <span class="ruby-constant">Remove</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">line</span> <span class="ruby-keyword">when</span> <span class="ruby-identifier">jQuery</span> <span class="ruby-identifier">supports</span> <span class="ruby-value">%xPATCH`</span> <span class="ruby-identifier">on</span> <span class="ruby-constant">IE8</span>.
  <span class="ruby-identifier">if</span> (<span class="ruby-identifier">params</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-string">'PATCH'</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">window</span>.<span class="ruby-constant">ActiveXObject</span> <span class="ruby-operator">&amp;&amp;</span>
        <span class="ruby-operator">!</span>(<span class="ruby-identifier">window</span>.<span class="ruby-identifier">external</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">window</span>.<span class="ruby-identifier">external</span>.<span class="ruby-identifier">msActiveXFilteringEnabled</span>)) {
    <span class="ruby-identifier">params</span>.<span class="ruby-identifier">xhr</span> = <span class="ruby-identifier">function</span>() {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">ActiveXObject</span>(<span class="ruby-string">&quot;Microsoft.XMLHTTP&quot;</span>);
    };
  }

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Make</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">request</span>, <span class="ruby-identifier">allowing</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">user</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">override</span> <span class="ruby-identifier">any</span> <span class="ruby-constant">Ajax</span> <span class="ruby-identifier">options</span>.
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">xhr</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">xhr</span> = <span class="ruby-constant">Backbone</span>.<span class="ruby-identifier">ajax</span>(<span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-identifier">params</span>, <span class="ruby-identifier">options</span>));
  <span class="ruby-identifier">model</span>.<span class="ruby-identifier">trigger</span>(<span class="ruby-string">'request'</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">xhr</span>, <span class="ruby-identifier">options</span>);
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">xhr</span>;
};

<span class="ruby-regexp">//</span> <span class="ruby-constant">Map</span> <span class="ruby-identifier">from</span> <span class="ruby-constant">CRUD</span> <span class="ruby-identifier">to</span> <span class="ruby-constant">HTTP</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">our</span> <span class="ruby-identifier">default</span> <span class="ruby-value">%xBackbone.sync`</span> <span class="ruby-identifier">implementation</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">methodMap</span> = {
  <span class="ruby-string">'create'</span><span class="ruby-operator">:</span> <span class="ruby-string">'POST'</span>,
  <span class="ruby-string">'update'</span><span class="ruby-operator">:</span> <span class="ruby-string">'PUT'</span>,
  <span class="ruby-string">'patch'</span><span class="ruby-operator">:</span>  <span class="ruby-string">'PATCH'</span>,
  <span class="ruby-string">'delete'</span><span class="ruby-operator">:</span> <span class="ruby-string">'DELETE'</span>,
  <span class="ruby-string">'read'</span><span class="ruby-operator">:</span>   <span class="ruby-string">'GET'</span>
};

<span class="ruby-regexp">//</span> <span class="ruby-constant">Set</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">default</span> <span class="ruby-identifier">implementation</span> <span class="ruby-identifier">of</span> <span class="ruby-value">%xBackbone.ajax`</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">proxy</span> <span class="ruby-identifier">through</span> <span class="ruby-identifier">to</span> <span class="ruby-value">%x$`</span>.
<span class="ruby-operator">/</span><span class="ruby-regexp">/ Override this if you'd like to use a different library.
Backbone.ajax = function() {
  return Backbone.$.ajax.apply(Backbone.$, arguments);
};

/</span><span class="ruby-operator">/</span> <span class="ruby-constant">Backbone</span>.<span class="ruby-constant">Router</span>
<span class="ruby-regexp">//</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span>

<span class="ruby-regexp">//</span> <span class="ruby-constant">Routers</span> <span class="ruby-identifier">map</span> <span class="ruby-identifier">faux</span><span class="ruby-operator">-</span><span class="ruby-constant">URLs</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">actions</span>, <span class="ruby-keyword">and</span> <span class="ruby-identifier">fire</span> <span class="ruby-identifier">events</span> <span class="ruby-keyword">when</span> <span class="ruby-identifier">routes</span> <span class="ruby-identifier">are</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">matched</span>. <span class="ruby-constant">Creating</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">new</span> <span class="ruby-identifier">one</span> <span class="ruby-identifier">sets</span> <span class="ruby-identifier">its</span> <span class="ruby-value">%xroutes`</span> <span class="ruby-identifier">hash</span>, <span class="ruby-keyword">if</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">statically</span>.
<span class="ruby-identifier">var</span> <span class="ruby-constant">Router</span> = <span class="ruby-constant">Backbone</span>.<span class="ruby-constant">Router</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">options</span>) {
  <span class="ruby-identifier">options</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">options</span> = {});
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">routes</span>) <span class="ruby-identifier">this</span>.<span class="ruby-identifier">routes</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">routes</span>;
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_bindRoutes</span>();
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">initialize</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
};

<span class="ruby-regexp">//</span> <span class="ruby-constant">Cached</span> <span class="ruby-identifier">regular</span> <span class="ruby-identifier">expressions</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">matching</span> <span class="ruby-identifier">named</span> <span class="ruby-identifier">param</span> <span class="ruby-identifier">parts</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">splatted</span>
<span class="ruby-regexp">//</span> <span class="ruby-identifier">parts</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">route</span> <span class="ruby-identifier">strings</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">optionalParam</span> = <span class="ruby-regexp">/\((.*?)\)/</span><span class="ruby-identifier">g</span>;
<span class="ruby-identifier">var</span> <span class="ruby-identifier">namedParam</span>    = <span class="ruby-regexp">/(\(\?)?:\w+/</span><span class="ruby-identifier">g</span>;
<span class="ruby-identifier">var</span> <span class="ruby-identifier">splatParam</span>    = <span class="ruby-regexp">/\*\w+/</span><span class="ruby-identifier">g</span>;
<span class="ruby-identifier">var</span> <span class="ruby-identifier">escapeRegExp</span>  = <span class="ruby-node">/[\-{}\[\]+?.,\\^$|#\s]/</span><span class="ruby-identifier">g</span>;

<span class="ruby-regexp">//</span> <span class="ruby-constant">Set</span> <span class="ruby-identifier">up</span> <span class="ruby-identifier">all</span> <span class="ruby-identifier">inheritable</span> <span class="ruby-operator">**</span><span class="ruby-constant">Backbone</span>.<span class="ruby-constant">Router</span><span class="ruby-operator">**</span> <span class="ruby-identifier">properties</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">methods</span>.
<span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">Router</span>.<span class="ruby-identifier">prototype</span>, <span class="ruby-constant">Events</span>, {

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Initialize</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">empty</span> <span class="ruby-identifier">function</span> <span class="ruby-identifier">by</span> <span class="ruby-identifier">default</span>. <span class="ruby-constant">Override</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">your</span> <span class="ruby-identifier">own</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">initialization</span> <span class="ruby-identifier">logic</span>.
  <span class="ruby-identifier">initialize</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(){},

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Manually</span> <span class="ruby-identifier">bind</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">single</span> <span class="ruby-identifier">named</span> <span class="ruby-identifier">route</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">callback</span>. <span class="ruby-constant">For</span> <span class="ruby-identifier">example</span><span class="ruby-operator">:</span>
  <span class="ruby-regexp">//</span>
  <span class="ruby-regexp">//</span>     <span class="ruby-identifier">this</span>.<span class="ruby-identifier">route</span>(<span class="ruby-string">'search/:query/p:num'</span>, <span class="ruby-string">'search'</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">query</span>, <span class="ruby-identifier">num</span>) {
  <span class="ruby-regexp">//</span>       <span class="ruby-operator">...</span>
  <span class="ruby-regexp">//</span>     });
  <span class="ruby-regexp">//</span>
  <span class="ruby-identifier">route</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">route</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">callback</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">_</span>.<span class="ruby-identifier">isRegExp</span>(<span class="ruby-identifier">route</span>)) <span class="ruby-identifier">route</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_routeToRegExp</span>(<span class="ruby-identifier">route</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">_</span>.<span class="ruby-identifier">isFunction</span>(<span class="ruby-identifier">name</span>)) {
      <span class="ruby-identifier">callback</span> = <span class="ruby-identifier">name</span>;
      <span class="ruby-identifier">name</span> = <span class="ruby-string">''</span>;
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">callback</span>) <span class="ruby-identifier">callback</span> = <span class="ruby-identifier">this</span>[<span class="ruby-identifier">name</span>];
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">router</span> = <span class="ruby-identifier">this</span>;
    <span class="ruby-constant">Backbone</span>.<span class="ruby-identifier">history</span>.<span class="ruby-identifier">route</span>(<span class="ruby-identifier">route</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">fragment</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">args</span> = <span class="ruby-identifier">router</span>.<span class="ruby-identifier">_extractParameters</span>(<span class="ruby-identifier">route</span>, <span class="ruby-identifier">fragment</span>);
      <span class="ruby-identifier">callback</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">callback</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">router</span>, <span class="ruby-identifier">args</span>);
      <span class="ruby-identifier">router</span>.<span class="ruby-identifier">trigger</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">router</span>, [<span class="ruby-string">'route:'</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">name</span>].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">args</span>));
      <span class="ruby-identifier">router</span>.<span class="ruby-identifier">trigger</span>(<span class="ruby-string">'route'</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">args</span>);
      <span class="ruby-constant">Backbone</span>.<span class="ruby-identifier">history</span>.<span class="ruby-identifier">trigger</span>(<span class="ruby-string">'route'</span>, <span class="ruby-identifier">router</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">args</span>);
    });
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Simple</span> <span class="ruby-identifier">proxy</span> <span class="ruby-identifier">to</span> <span class="ruby-value">%xBackbone.history`</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">save</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">fragment</span> <span class="ruby-identifier">into</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">history</span>.
  <span class="ruby-identifier">navigate</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">fragment</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-constant">Backbone</span>.<span class="ruby-identifier">history</span>.<span class="ruby-identifier">navigate</span>(<span class="ruby-identifier">fragment</span>, <span class="ruby-identifier">options</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Bind</span> <span class="ruby-identifier">all</span> <span class="ruby-identifier">defined</span> <span class="ruby-identifier">routes</span> <span class="ruby-identifier">to</span> <span class="ruby-value">%xBackbone.history`</span>. <span class="ruby-constant">We</span> <span class="ruby-identifier">have</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">reverse</span> <span class="ruby-identifier">the</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">order</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">routes</span> <span class="ruby-identifier">here</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">support</span> <span class="ruby-identifier">behavior</span> <span class="ruby-identifier">where</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">most</span> <span class="ruby-identifier">general</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">routes</span> <span class="ruby-identifier">can</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">defined</span> <span class="ruby-identifier">at</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">bottom</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">route</span> <span class="ruby-identifier">map</span>.
  <span class="ruby-identifier">_bindRoutes</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">routes</span>) <span class="ruby-keyword">return</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">routes</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">result</span>(<span class="ruby-identifier">this</span>, <span class="ruby-string">'routes'</span>);
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">route</span>, <span class="ruby-identifier">routes</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">keys</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">routes</span>);
    <span class="ruby-keyword">while</span> ((<span class="ruby-identifier">route</span> = <span class="ruby-identifier">routes</span>.<span class="ruby-identifier">pop</span>()) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">route</span>(<span class="ruby-identifier">route</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">routes</span>[<span class="ruby-identifier">route</span>]);
    }
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Convert</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">route</span> <span class="ruby-identifier">string</span> <span class="ruby-identifier">into</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">regular</span> <span class="ruby-identifier">expression</span>, <span class="ruby-identifier">suitable</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">matching</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">against</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">current</span> <span class="ruby-identifier">location</span> <span class="ruby-identifier">hash</span>.
  <span class="ruby-identifier">_routeToRegExp</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">route</span>) {
    <span class="ruby-identifier">route</span> = <span class="ruby-identifier">route</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">escapeRegExp</span>, <span class="ruby-string">'\$&amp;'</span>)
                 .<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">optionalParam</span>, <span class="ruby-string">'(?:$1)?'</span>)
                 .<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">namedParam</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">match</span>, <span class="ruby-identifier">optional</span>){
                   <span class="ruby-keyword">return</span> <span class="ruby-identifier">optional</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">match</span> <span class="ruby-operator">:</span> <span class="ruby-string">'([^\/]+)'</span>;
                 })
                 .<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">splatParam</span>, <span class="ruby-string">'(.*?)'</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">RegExp</span>(<span class="ruby-string">'^'</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">route</span> <span class="ruby-operator">+</span> <span class="ruby-string">'$'</span>);
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Given</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">route</span>, <span class="ruby-keyword">and</span> <span class="ruby-identifier">a</span> <span class="ruby-constant">URL</span> <span class="ruby-identifier">fragment</span> <span class="ruby-identifier">that</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">matches</span>, <span class="ruby-keyword">return</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">array</span> <span class="ruby-identifier">of</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">extracted</span> <span class="ruby-identifier">decoded</span> <span class="ruby-identifier">parameters</span>. <span class="ruby-constant">Empty</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">unmatched</span> <span class="ruby-identifier">parameters</span> <span class="ruby-identifier">will</span> <span class="ruby-identifier">be</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">treated</span> <span class="ruby-identifier">as</span> <span class="ruby-value">%xnull`</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">normalize</span> <span class="ruby-identifier">cross</span><span class="ruby-operator">-</span><span class="ruby-identifier">browser</span> <span class="ruby-identifier">behavior</span>.
  <span class="ruby-identifier">_extractParameters</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">route</span>, <span class="ruby-identifier">fragment</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">params</span> = <span class="ruby-identifier">route</span>.<span class="ruby-identifier">exec</span>(<span class="ruby-identifier">fragment</span>).<span class="ruby-identifier">slice</span>(<span class="ruby-value">1</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">_</span>.<span class="ruby-identifier">map</span>(<span class="ruby-identifier">params</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">param</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">param</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">decodeURIComponent</span>(<span class="ruby-identifier">param</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">null</span>;
    });
  }

});

<span class="ruby-regexp">//</span> <span class="ruby-constant">Backbone</span>.<span class="ruby-constant">History</span>
<span class="ruby-regexp">//</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span>

<span class="ruby-regexp">//</span> <span class="ruby-constant">Handles</span> <span class="ruby-identifier">cross</span><span class="ruby-operator">-</span><span class="ruby-identifier">browser</span> <span class="ruby-identifier">history</span> <span class="ruby-identifier">management</span>, <span class="ruby-identifier">based</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">either</span>
<span class="ruby-regexp">//</span> [<span class="ruby-identifier">pushState</span>](<span class="ruby-identifier">http</span>:<span class="ruby-operator">/</span><span class="ruby-regexp">/diveintohtml5.info/</span><span class="ruby-identifier">history</span>.<span class="ruby-identifier">html</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">real</span> <span class="ruby-constant">URLs</span>, <span class="ruby-keyword">or</span>
<span class="ruby-regexp">//</span> [<span class="ruby-identifier">onhashchange</span>](<span class="ruby-identifier">https</span>:<span class="ruby-operator">/</span><span class="ruby-regexp">/developer.mozilla.org/</span><span class="ruby-identifier">n</span><span class="ruby-operator">-</span><span class="ruby-constant">US</span><span class="ruby-operator">/</span><span class="ruby-identifier">docs</span><span class="ruby-operator">/</span><span class="ruby-constant">DOM</span><span class="ruby-operator">/</span><span class="ruby-identifier">window</span>.<span class="ruby-identifier">onhashchange</span>)
<span class="ruby-regexp">//</span> <span class="ruby-keyword">and</span> <span class="ruby-constant">URL</span> <span class="ruby-identifier">fragments</span>. <span class="ruby-constant">If</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">browser</span> <span class="ruby-identifier">supports</span> <span class="ruby-identifier">neither</span> (<span class="ruby-identifier">old</span> <span class="ruby-constant">IE</span>, <span class="ruby-identifier">natch</span>),
<span class="ruby-regexp">//</span> <span class="ruby-identifier">falls</span> <span class="ruby-identifier">back</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">polling</span>.
<span class="ruby-identifier">var</span> <span class="ruby-constant">History</span> = <span class="ruby-constant">Backbone</span>.<span class="ruby-constant">History</span> = <span class="ruby-identifier">function</span>() {
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">handlers</span> = [];
  <span class="ruby-identifier">_</span>.<span class="ruby-identifier">bindAll</span>(<span class="ruby-identifier">this</span>, <span class="ruby-string">'checkUrl'</span>);

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Ensure</span> <span class="ruby-identifier">that</span> <span class="ruby-value">%xHistory`</span> <span class="ruby-identifier">can</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">used</span> <span class="ruby-identifier">outside</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">browser</span>.
  <span class="ruby-identifier">if</span> (<span class="ruby-identifier">typeof</span> <span class="ruby-identifier">window</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">'undefined'</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">location</span> = <span class="ruby-identifier">window</span>.<span class="ruby-identifier">location</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">history</span> = <span class="ruby-identifier">window</span>.<span class="ruby-identifier">history</span>;
  }
};

<span class="ruby-regexp">//</span> <span class="ruby-constant">Cached</span> <span class="ruby-identifier">regex</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">stripping</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">leading</span> <span class="ruby-identifier">hash</span><span class="ruby-operator">/</span><span class="ruby-identifier">slash</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">trailing</span> <span class="ruby-identifier">space</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">routeStripper</span> = <span class="ruby-node">/^[#\/]|\s+$/</span><span class="ruby-identifier">g</span>;

<span class="ruby-regexp">//</span> <span class="ruby-constant">Cached</span> <span class="ruby-identifier">regex</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">stripping</span> <span class="ruby-identifier">leading</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">trailing</span> <span class="ruby-identifier">slashes</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">rootStripper</span> = <span class="ruby-regexp">/^\/+|\/+$/</span><span class="ruby-identifier">g</span>;

<span class="ruby-regexp">//</span> <span class="ruby-constant">Cached</span> <span class="ruby-identifier">regex</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">detecting</span> <span class="ruby-constant">MSIE</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">isExplorer</span> = <span class="ruby-regexp">/msie [\w.]+/</span>;

<span class="ruby-regexp">//</span> <span class="ruby-constant">Cached</span> <span class="ruby-identifier">regex</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">removing</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">trailing</span> <span class="ruby-identifier">slash</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">trailingSlash</span> = <span class="ruby-regexp">/\/$/</span>;

<span class="ruby-regexp">//</span> <span class="ruby-constant">Has</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">history</span> <span class="ruby-identifier">handling</span> <span class="ruby-identifier">already</span> <span class="ruby-identifier">been</span> <span class="ruby-identifier">started?</span>
<span class="ruby-constant">History</span>.<span class="ruby-identifier">started</span> = <span class="ruby-keyword">false</span>;

<span class="ruby-regexp">//</span> <span class="ruby-constant">Set</span> <span class="ruby-identifier">up</span> <span class="ruby-identifier">all</span> <span class="ruby-identifier">inheritable</span> <span class="ruby-operator">**</span><span class="ruby-constant">Backbone</span>.<span class="ruby-constant">History</span><span class="ruby-operator">**</span> <span class="ruby-identifier">properties</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">methods</span>.
<span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">History</span>.<span class="ruby-identifier">prototype</span>, <span class="ruby-constant">Events</span>, {

  <span class="ruby-regexp">//</span> <span class="ruby-constant">The</span> <span class="ruby-identifier">default</span> <span class="ruby-identifier">interval</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">poll</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">hash</span> <span class="ruby-identifier">changes</span>, <span class="ruby-keyword">if</span> <span class="ruby-identifier">necessary</span>, <span class="ruby-identifier">is</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">twenty</span> <span class="ruby-identifier">times</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">second</span>.
  <span class="ruby-identifier">interval</span><span class="ruby-operator">:</span> <span class="ruby-value">50</span>,

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Gets</span> <span class="ruby-identifier">the</span> <span class="ruby-keyword">true</span> <span class="ruby-identifier">hash</span> <span class="ruby-identifier">value</span>. <span class="ruby-constant">Cannot</span> <span class="ruby-identifier">use</span> <span class="ruby-identifier">location</span>.<span class="ruby-identifier">hash</span> <span class="ruby-identifier">directly</span> <span class="ruby-identifier">due</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">bug</span>
  <span class="ruby-regexp">//</span> <span class="ruby-keyword">in</span> <span class="ruby-constant">Firefox</span> <span class="ruby-identifier">where</span> <span class="ruby-identifier">location</span>.<span class="ruby-identifier">hash</span> <span class="ruby-identifier">will</span> <span class="ruby-identifier">always</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">decoded</span>.
  <span class="ruby-identifier">getHash</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">window</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">match</span> = (<span class="ruby-identifier">window</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>).<span class="ruby-identifier">location</span>.<span class="ruby-identifier">href</span>.<span class="ruby-identifier">match</span>(<span class="ruby-node">/#(.*)$/</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">match</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-string">''</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Get</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">cross</span><span class="ruby-operator">-</span><span class="ruby-identifier">browser</span> <span class="ruby-identifier">normalized</span> <span class="ruby-constant">URL</span> <span class="ruby-identifier">fragment</span>, <span class="ruby-identifier">either</span> <span class="ruby-identifier">from</span> <span class="ruby-identifier">the</span> <span class="ruby-constant">URL</span>,
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">hash</span>, <span class="ruby-keyword">or</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">override</span>.
  <span class="ruby-identifier">getFragment</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">fragment</span>, <span class="ruby-identifier">forcePushState</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">fragment</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_hasPushState</span> <span class="ruby-operator">||</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">_wantsHashChange</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">forcePushState</span>) {
        <span class="ruby-identifier">fragment</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">location</span>.<span class="ruby-identifier">pathname</span>;
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">root</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">root</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">trailingSlash</span>, <span class="ruby-string">''</span>);
        <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">indexOf</span>(<span class="ruby-identifier">root</span>)) <span class="ruby-identifier">fragment</span> = <span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">substr</span>(<span class="ruby-identifier">root</span>.<span class="ruby-identifier">length</span>);
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">fragment</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">getHash</span>();
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">routeStripper</span>, <span class="ruby-string">''</span>);
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Start</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">hash</span> <span class="ruby-identifier">change</span> <span class="ruby-identifier">handling</span>, <span class="ruby-identifier">returning</span> <span class="ruby-value">%xtrue`</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">current</span> <span class="ruby-constant">URL</span> <span class="ruby-identifier">matches</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">existing</span> <span class="ruby-identifier">route</span>, <span class="ruby-keyword">and</span> <span class="ruby-value">%xfalse`</span> <span class="ruby-identifier">otherwise</span>.
  <span class="ruby-identifier">start</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">options</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-constant">History</span>.<span class="ruby-identifier">started</span>) <span class="ruby-identifier">throw</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Error</span>(<span class="ruby-string">&quot;Backbone.history has already been started&quot;</span>);
    <span class="ruby-constant">History</span>.<span class="ruby-identifier">started</span> = <span class="ruby-keyword">true</span>;

    <span class="ruby-regexp">//</span> <span class="ruby-constant">Figure</span> <span class="ruby-identifier">out</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">initial</span> <span class="ruby-identifier">configuration</span>. <span class="ruby-constant">Do</span> <span class="ruby-identifier">we</span> <span class="ruby-identifier">need</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">iframe?</span>
    <span class="ruby-regexp">//</span> <span class="ruby-constant">Is</span> <span class="ruby-identifier">pushState</span> <span class="ruby-identifier">desired</span> <span class="ruby-operator">...</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">available?</span>
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">options</span>          = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>({}, {<span class="ruby-identifier">root</span><span class="ruby-operator">:</span> <span class="ruby-string">'/'</span>}, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">options</span>, <span class="ruby-identifier">options</span>);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">root</span>             = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">options</span>.<span class="ruby-identifier">root</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_wantsHashChange</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">options</span>.<span class="ruby-identifier">hashChange</span> <span class="ruby-operator">!=</span>= <span class="ruby-keyword">false</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_wantsPushState</span>  = <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">options</span>.<span class="ruby-identifier">pushState</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_hasPushState</span>    = <span class="ruby-operator">!</span><span class="ruby-operator">!</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">options</span>.<span class="ruby-identifier">pushState</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">history</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">history</span>.<span class="ruby-identifier">pushState</span>);
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">fragment</span>          = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">getFragment</span>();
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">docMode</span>           = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">documentMode</span>;
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">oldIE</span>             = (<span class="ruby-identifier">isExplorer</span>.<span class="ruby-identifier">exec</span>(<span class="ruby-identifier">navigator</span>.<span class="ruby-identifier">userAgent</span>.<span class="ruby-identifier">toLowerCase</span>()) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">docMode</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">docMode</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">7</span>));

    <span class="ruby-regexp">//</span> <span class="ruby-constant">Normalize</span> <span class="ruby-identifier">root</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">always</span> <span class="ruby-identifier">include</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">leading</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">trailing</span> <span class="ruby-identifier">slash</span>.
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">root</span> = (<span class="ruby-string">'/'</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">root</span> <span class="ruby-operator">+</span> <span class="ruby-string">'/'</span>).<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">rootStripper</span>, <span class="ruby-string">'/'</span>);

    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">oldIE</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_wantsHashChange</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">iframe</span> = <span class="ruby-constant">Backbone</span>.$(<span class="ruby-string">'&lt;iframe src=&quot;javascript:0&quot; tabindex=&quot;-1&quot; /&gt;'</span>).<span class="ruby-identifier">hide</span>().<span class="ruby-identifier">appendTo</span>(<span class="ruby-string">'body'</span>)[<span class="ruby-value">0</span>].<span class="ruby-identifier">contentWindow</span>;
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">navigate</span>(<span class="ruby-identifier">fragment</span>);
    }

    <span class="ruby-regexp">//</span> <span class="ruby-constant">Depending</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">whether</span> <span class="ruby-identifier">we</span><span class="ruby-string">'re using pushState or hashes, and whether
    // '</span><span class="ruby-identifier">onhashchange</span><span class="ruby-string">' is supported, determine how we check the URL state.
    if (this._hasPushState) {
      Backbone.$(window).on('</span><span class="ruby-identifier">popstate</span><span class="ruby-string">', this.checkUrl);
    } else if (this._wantsHashChange &amp;&amp; ('</span><span class="ruby-identifier">onhashchange</span><span class="ruby-string">' in window) &amp;&amp; !oldIE) {
      Backbone.$(window).on('</span><span class="ruby-identifier">hashchange</span><span class="ruby-string">', this.checkUrl);
    } else if (this._wantsHashChange) {
      this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
    }

    // Determine if we need to change the base url, for a pushState link
    // opened by a non-pushState browser.
    this.fragment = fragment;
    var loc = this.location;
    var atRoot = loc.pathname.replace(/[^\/]$/, '</span><span class="ruby-node">$&amp;</span><span class="ruby-operator">/</span><span class="ruby-string">') === this.root;

    // If we'</span><span class="ruby-identifier">ve</span> <span class="ruby-identifier">started</span> <span class="ruby-identifier">off</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">route</span> <span class="ruby-identifier">from</span> <span class="ruby-identifier">a</span> <span class="ruby-value">%xpushState`</span><span class="ruby-operator">-</span><span class="ruby-identifier">enabled</span> <span class="ruby-identifier">browser</span>,
    <span class="ruby-regexp">//</span> <span class="ruby-identifier">but</span> <span class="ruby-identifier">we</span><span class="ruby-string">'re currently in a browser that doesn'</span><span class="ruby-identifier">t</span> <span class="ruby-identifier">support</span> <span class="ruby-identifier">it</span><span class="ruby-operator">...</span>
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_wantsHashChange</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_wantsPushState</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">_hasPushState</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">atRoot</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fragment</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">getFragment</span>(<span class="ruby-identifier">null</span>, <span class="ruby-keyword">true</span>);
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">location</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">root</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">location</span>.<span class="ruby-identifier">search</span> <span class="ruby-operator">+</span> <span class="ruby-string">'#'</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fragment</span>);
      <span class="ruby-regexp">//</span> <span class="ruby-constant">Return</span> <span class="ruby-identifier">immediately</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">browser</span> <span class="ruby-identifier">will</span> <span class="ruby-keyword">do</span> <span class="ruby-identifier">redirect</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">new</span> <span class="ruby-identifier">url</span>
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;

    <span class="ruby-regexp">//</span> <span class="ruby-constant">Or</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">we</span><span class="ruby-string">'ve started out with a hash-based route, but we'</span><span class="ruby-identifier">re</span> <span class="ruby-identifier">currently</span>
    <span class="ruby-regexp">//</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">browser</span> <span class="ruby-identifier">where</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">could</span> <span class="ruby-identifier">be</span> <span class="ruby-value">%xpushState`</span><span class="ruby-operator">-</span><span class="ruby-identifier">based</span> <span class="ruby-identifier">instead</span><span class="ruby-operator">...</span>
    } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_wantsPushState</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_hasPushState</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">atRoot</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">loc</span>.<span class="ruby-identifier">hash</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fragment</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">getHash</span>().<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">routeStripper</span>, <span class="ruby-string">''</span>);
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">history</span>.<span class="ruby-identifier">replaceState</span>({}, <span class="ruby-identifier">document</span>.<span class="ruby-identifier">title</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">root</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fragment</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">loc</span>.<span class="ruby-identifier">search</span>);
    }

    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">options</span>.<span class="ruby-identifier">silent</span>) <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">loadUrl</span>();
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Disable</span> <span class="ruby-constant">Backbone</span>.<span class="ruby-identifier">history</span>, <span class="ruby-identifier">perhaps</span> <span class="ruby-identifier">temporarily</span>. <span class="ruby-constant">Not</span> <span class="ruby-identifier">useful</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">real</span> <span class="ruby-identifier">app</span>,
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">but</span> <span class="ruby-identifier">possibly</span> <span class="ruby-identifier">useful</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">unit</span> <span class="ruby-identifier">testing</span> <span class="ruby-constant">Routers</span>.
  <span class="ruby-identifier">stop</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-constant">Backbone</span>.$(<span class="ruby-identifier">window</span>).<span class="ruby-identifier">off</span>(<span class="ruby-string">'popstate'</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">checkUrl</span>).<span class="ruby-identifier">off</span>(<span class="ruby-string">'hashchange'</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">checkUrl</span>);
    <span class="ruby-identifier">clearInterval</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_checkUrlInterval</span>);
    <span class="ruby-constant">History</span>.<span class="ruby-identifier">started</span> = <span class="ruby-keyword">false</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Add</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">route</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">tested</span> <span class="ruby-keyword">when</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">fragment</span> <span class="ruby-identifier">changes</span>. <span class="ruby-constant">Routes</span> <span class="ruby-identifier">added</span> <span class="ruby-identifier">later</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">may</span> <span class="ruby-identifier">override</span> <span class="ruby-identifier">previous</span> <span class="ruby-identifier">routes</span>.
  <span class="ruby-identifier">route</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">route</span>, <span class="ruby-identifier">callback</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">handlers</span>.<span class="ruby-identifier">unshift</span>({<span class="ruby-identifier">route</span><span class="ruby-operator">:</span> <span class="ruby-identifier">route</span>, <span class="ruby-identifier">callback</span><span class="ruby-operator">:</span> <span class="ruby-identifier">callback</span>});
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Checks</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">current</span> <span class="ruby-constant">URL</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">see</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">has</span> <span class="ruby-identifier">changed</span>, <span class="ruby-keyword">and</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">has</span>,
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">calls</span> <span class="ruby-value">%xloadUrl`</span>, <span class="ruby-identifier">normalizing</span> <span class="ruby-identifier">across</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">hidden</span> <span class="ruby-identifier">iframe</span>.
  <span class="ruby-identifier">checkUrl</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">e</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">current</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">getFragment</span>();
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">current</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fragment</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">iframe</span>) {
      <span class="ruby-identifier">current</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">getFragment</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">getHash</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">iframe</span>));
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">current</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fragment</span>) <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">iframe</span>) <span class="ruby-identifier">this</span>.<span class="ruby-identifier">navigate</span>(<span class="ruby-identifier">current</span>);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">loadUrl</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">loadUrl</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">getHash</span>());
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Attempt</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">load</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">current</span> <span class="ruby-constant">URL</span> <span class="ruby-identifier">fragment</span>. <span class="ruby-constant">If</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">route</span> <span class="ruby-identifier">succeeds</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">a</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">match</span>, <span class="ruby-identifier">returns</span> <span class="ruby-value">%xtrue`</span>. <span class="ruby-constant">If</span> <span class="ruby-identifier">no</span> <span class="ruby-identifier">defined</span> <span class="ruby-identifier">routes</span> <span class="ruby-identifier">matches</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">fragment</span>,
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">returns</span> <span class="ruby-value">%xfalse`</span>.
  <span class="ruby-identifier">loadUrl</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">fragmentOverride</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">fragment</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fragment</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">getFragment</span>(<span class="ruby-identifier">fragmentOverride</span>);
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">matched</span> = <span class="ruby-identifier">_</span>.<span class="ruby-identifier">any</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">handlers</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">handler</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">handler</span>.<span class="ruby-identifier">route</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">fragment</span>)) {
        <span class="ruby-identifier">handler</span>.<span class="ruby-identifier">callback</span>(<span class="ruby-identifier">fragment</span>);
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
      }
    });
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">matched</span>;
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Save</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">fragment</span> <span class="ruby-identifier">into</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">hash</span> <span class="ruby-identifier">history</span>, <span class="ruby-keyword">or</span> <span class="ruby-identifier">replace</span> <span class="ruby-identifier">the</span> <span class="ruby-constant">URL</span> <span class="ruby-identifier">state</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">the</span>
  <span class="ruby-regexp">//</span> <span class="ruby-string">'replace'</span> <span class="ruby-identifier">option</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">passed</span>. <span class="ruby-constant">You</span> <span class="ruby-identifier">are</span> <span class="ruby-identifier">responsible</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">properly</span> <span class="ruby-constant">URL</span><span class="ruby-operator">-</span><span class="ruby-identifier">encoding</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">fragment</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">advance</span>.
  <span class="ruby-operator">/</span><span class="ruby-regexp">/
  /</span><span class="ruby-operator">/</span> <span class="ruby-constant">The</span> <span class="ruby-identifier">options</span> <span class="ruby-identifier">object</span> <span class="ruby-identifier">can</span> <span class="ruby-identifier">contain</span> <span class="ruby-value">%xtrigger: true`</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">you</span> <span class="ruby-identifier">wish</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">have</span> <span class="ruby-identifier">the</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">route</span> <span class="ruby-identifier">callback</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">fired</span> (<span class="ruby-keyword">not</span> <span class="ruby-identifier">usually</span> <span class="ruby-identifier">desirable</span>), <span class="ruby-keyword">or</span> <span class="ruby-value">%xreplace: true`</span>, <span class="ruby-keyword">if</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">you</span> <span class="ruby-identifier">wish</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">modify</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">current</span> <span class="ruby-constant">URL</span> <span class="ruby-identifier">without</span> <span class="ruby-identifier">adding</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">entry</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">history</span>.
  <span class="ruby-identifier">navigate</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">fragment</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-constant">History</span>.<span class="ruby-identifier">started</span>) <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">options</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">options</span> <span class="ruby-operator">===</span> <span class="ruby-keyword">true</span>) <span class="ruby-identifier">options</span> = {<span class="ruby-identifier">trigger</span><span class="ruby-operator">:</span> <span class="ruby-identifier">options</span>};
    <span class="ruby-identifier">fragment</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">getFragment</span>(<span class="ruby-identifier">fragment</span> <span class="ruby-operator">||</span> <span class="ruby-string">''</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">fragment</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">fragment</span>) <span class="ruby-keyword">return</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fragment</span> = <span class="ruby-identifier">fragment</span>;
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">url</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">root</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">fragment</span>;

    <span class="ruby-regexp">//</span> <span class="ruby-constant">If</span> <span class="ruby-identifier">pushState</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">available</span>, <span class="ruby-identifier">we</span> <span class="ruby-identifier">use</span> <span class="ruby-identifier">it</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">fragment</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">real</span> <span class="ruby-constant">URL</span>.
    <span class="ruby-identifier">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_hasPushState</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">history</span>[<span class="ruby-identifier">options</span>.<span class="ruby-identifier">replace</span> <span class="ruby-operator">?</span> <span class="ruby-string">'replaceState'</span> <span class="ruby-operator">:</span> <span class="ruby-string">'pushState'</span>]({}, <span class="ruby-identifier">document</span>.<span class="ruby-identifier">title</span>, <span class="ruby-identifier">url</span>);

    <span class="ruby-regexp">//</span> <span class="ruby-constant">If</span> <span class="ruby-identifier">hash</span> <span class="ruby-identifier">changes</span> <span class="ruby-identifier">haven</span><span class="ruby-string">'t been explicitly disabled, update the hash
    // fragment to store history.
    } else if (this._wantsHashChange) {
      this._updateHash(this.location, fragment, options.replace);
      if (this.iframe &amp;&amp; (fragment !== this.getFragment(this.getHash(this.iframe)))) {
        // Opening and closing the iframe tricks IE7 and earlier to push a
        // history entry on hash-tag change.  When replace is true, we don'</span><span class="ruby-identifier">t</span>
        <span class="ruby-regexp">//</span> <span class="ruby-identifier">want</span> <span class="ruby-identifier">this</span>.
        <span class="ruby-identifier">if</span>(<span class="ruby-operator">!</span><span class="ruby-identifier">options</span>.<span class="ruby-identifier">replace</span>) <span class="ruby-identifier">this</span>.<span class="ruby-identifier">iframe</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">open</span>().<span class="ruby-identifier">close</span>();
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_updateHash</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">iframe</span>.<span class="ruby-identifier">location</span>, <span class="ruby-identifier">fragment</span>, <span class="ruby-identifier">options</span>.<span class="ruby-identifier">replace</span>);
      }

    <span class="ruby-regexp">//</span> <span class="ruby-constant">If</span> <span class="ruby-identifier">you</span><span class="ruby-string">'ve told us that you explicitly don'</span><span class="ruby-identifier">t</span> <span class="ruby-identifier">want</span> <span class="ruby-identifier">fallback</span> <span class="ruby-identifier">hashchange</span><span class="ruby-operator">-</span>
    <span class="ruby-regexp">//</span> <span class="ruby-identifier">based</span> <span class="ruby-identifier">history</span>, <span class="ruby-keyword">then</span> <span class="ruby-value">%xnavigate`</span> <span class="ruby-identifier">becomes</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">page</span> <span class="ruby-identifier">refresh</span>.
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">location</span>.<span class="ruby-identifier">assign</span>(<span class="ruby-identifier">url</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">trigger</span>) <span class="ruby-identifier">this</span>.<span class="ruby-identifier">loadUrl</span>(<span class="ruby-identifier">fragment</span>);
  },

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Update</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">hash</span> <span class="ruby-identifier">location</span>, <span class="ruby-identifier">either</span> <span class="ruby-identifier">replacing</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">current</span> <span class="ruby-identifier">entry</span>, <span class="ruby-keyword">or</span> <span class="ruby-identifier">adding</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">new</span> <span class="ruby-identifier">one</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">browser</span> <span class="ruby-identifier">history</span>.
  <span class="ruby-identifier">_updateHash</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">location</span>, <span class="ruby-identifier">fragment</span>, <span class="ruby-identifier">replace</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">replace</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">href</span> = <span class="ruby-identifier">location</span>.<span class="ruby-identifier">href</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-node">/(javascript:|#).*$/</span>, <span class="ruby-string">''</span>);
      <span class="ruby-identifier">location</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">href</span> <span class="ruby-operator">+</span> <span class="ruby-string">'#'</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">fragment</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-regexp">//</span> <span class="ruby-constant">Some</span> <span class="ruby-identifier">browsers</span> <span class="ruby-identifier">require</span> <span class="ruby-identifier">that</span> <span class="ruby-value">%xhash`</span> <span class="ruby-identifier">contains</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">leading</span> <span class="ruby-comment">#.</span>
      <span class="ruby-identifier">location</span>.<span class="ruby-identifier">hash</span> = <span class="ruby-string">'#'</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">fragment</span>;
    }
  }

});

<span class="ruby-regexp">//</span> <span class="ruby-constant">Create</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">default</span> <span class="ruby-constant">Backbone</span>.<span class="ruby-identifier">history</span>.
<span class="ruby-constant">Backbone</span>.<span class="ruby-identifier">history</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">History</span>;

<span class="ruby-regexp">//</span> <span class="ruby-constant">Helpers</span>
<span class="ruby-regexp">//</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span>

<span class="ruby-regexp">//</span> <span class="ruby-constant">Helper</span> <span class="ruby-identifier">function</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">correctly</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">up</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">prototype</span> <span class="ruby-identifier">chain</span>, <span class="ruby-keyword">for</span> <span class="ruby-identifier">subclasses</span>.
<span class="ruby-operator">/</span><span class="ruby-regexp">/ Similar to `goog.inherits`, but uses a hash of prototype properties and
/</span><span class="ruby-operator">/</span> <span class="ruby-keyword">class</span> <span class="ruby-identifier">properties</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">extended</span>.
<span class="ruby-identifier">var</span> <span class="ruby-identifier">extend</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">protoProps</span>, <span class="ruby-identifier">staticProps</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">parent</span> = <span class="ruby-identifier">this</span>;
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">child</span>;

  <span class="ruby-regexp">//</span> <span class="ruby-constant">The</span> <span class="ruby-identifier">constructor</span> <span class="ruby-identifier">function</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">new</span> <span class="ruby-identifier">subclass</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">either</span> <span class="ruby-identifier">defined</span> <span class="ruby-identifier">by</span> <span class="ruby-identifier">you</span>
  <span class="ruby-regexp">//</span> (<span class="ruby-identifier">the</span> <span class="ruby-string">&quot;constructor&quot;</span> <span class="ruby-identifier">property</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">your</span> <span class="ruby-value">%xextend`</span> <span class="ruby-identifier">definition</span>), <span class="ruby-keyword">or</span> <span class="ruby-identifier">defaulted</span>
  <span class="ruby-regexp">//</span> <span class="ruby-identifier">by</span> <span class="ruby-identifier">us</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">simply</span> <span class="ruby-identifier">call</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">parent</span><span class="ruby-string">'s constructor.
  if (protoProps &amp;&amp; _.has(protoProps, '</span><span class="ruby-identifier">constructor</span><span class="ruby-string">')) {
    child = protoProps.constructor;
  } else {
    child = function(){ return parent.apply(this, arguments); };
  }

  // Add static properties to the constructor function, if supplied.
  _.extend(child, parent, staticProps);

  // Set the prototype chain to inherit from `parent`, without calling
  // `parent`'</span><span class="ruby-identifier">s</span> <span class="ruby-identifier">constructor</span> <span class="ruby-identifier">function</span>.
  <span class="ruby-identifier">var</span> <span class="ruby-constant">Surrogate</span> = <span class="ruby-identifier">function</span>(){ <span class="ruby-identifier">this</span>.<span class="ruby-identifier">constructor</span> = <span class="ruby-identifier">child</span>; };
  <span class="ruby-constant">Surrogate</span>.<span class="ruby-identifier">prototype</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">prototype</span>;
  <span class="ruby-identifier">child</span>.<span class="ruby-identifier">prototype</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Surrogate</span>;

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Add</span> <span class="ruby-identifier">prototype</span> <span class="ruby-identifier">properties</span> (<span class="ruby-identifier">instance</span> <span class="ruby-identifier">properties</span>) <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">subclass</span>,
  <span class="ruby-regexp">//</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">supplied</span>.
  <span class="ruby-identifier">if</span> (<span class="ruby-identifier">protoProps</span>) <span class="ruby-identifier">_</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-identifier">child</span>.<span class="ruby-identifier">prototype</span>, <span class="ruby-identifier">protoProps</span>);

  <span class="ruby-regexp">//</span> <span class="ruby-constant">Set</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">convenience</span> <span class="ruby-identifier">property</span> <span class="ruby-keyword">in</span> <span class="ruby-keyword">case</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">parent</span><span class="ruby-string">'s prototype is needed
  // later.
  child.__super__ = parent.prototype;

  return child;
};

// Set up inheritance for the model, collection, router, view and history.
Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

// Throw an error when a URL is needed, and none is supplied.
var urlError = function() {
  throw new Error('</span><span class="ruby-constant">A</span> <span class="ruby-string">&quot;url&quot;</span> <span class="ruby-identifier">property</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">function</span> <span class="ruby-identifier">must</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">specified</span><span class="ruby-string">');
};

// Wrap an optional error callback with a fallback error event.
var wrapError = function (model, options) {
  var error = options.error;
  options.error = function(resp) {
    if (error) error(model, resp, options);
    model.trigger('</span><span class="ruby-identifier">error</span><span class="ruby-string">', model, resp, options);
  };
};
</span></pre>

<p>}).call(this);</p>

</div>



<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 4.0.0.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

